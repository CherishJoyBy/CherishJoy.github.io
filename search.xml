<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo搭建]]></title>
    <url>%2F2017%2F06%2F10%2FHexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开始安装1$ npm install -g hexo 出错,使用淘宝镜像1$ npm config set registry https://registry.npm.taobao.org 出现权限不允许,修改该文件的权限:/usr/local/lib/node_modules,找到文件夹右击,权限改为:读与写创建一个文件夹名为:Blog,cd到Blog文件夹中1$ cd /Users/lbymac/Blog 初始化hex1$ hexo init 文件生成1$ hexo generate 本地服务测试1$ hexo server 在_config.yml文件中添加以下信息123type: git repository: https://github.com/CherishJoyBy/CherishJoyBy.github.io.gitbranch: master git上传插件安装1$ npm install hexo-deployer-git —save 清空1$ hexo clean 生成1$ hexo generate 部署上传1$ hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之苹果开发者账号注册申请流程]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%8B%B9%E6%9E%9C%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS账号注册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之CocoaAsyncSocket使用]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BCocoaAsyncSocket%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了CocoaAsyncSocket库中GCDAsyncSocket类的使用、粘包处理以及时间延迟测试. 一.CocoaAsyncSocket介绍CocoaAsyncSocket中主要包含两个类: 1.GCDAsyncSocket. 用GCD搭建的基于TCP/IP协议的socket网络库GCDAsyncSocket is a TCP/IP socket networking library built atop Grand Central Dispatch. – 引自CocoaAsyncSocket. 2.GCDAsyncUdpSocket. 用GCD搭建的基于UDP/IP协议的socket网络库.GCDAsyncUdpSocket is a UDP/IP socket networking library built atop Grand Central Dispatch..– 引自CocoaAsyncSocket. 二.下载CocoaAsyncSocket首先,需要到这里下载CocoaAsyncSocket.下载后可以看到文件所在位置. 这里只要拷贝以下两个文件到项目中. 三.客户端因为,大部分项目已经有服务端socket,所以,先讲解客户端创建过程. 步骤:1.继承GCDAsyncSocketDelegate协议.2.声明属性12// 客户端socket@property (strong, nonatomic) GCDAsyncSocket *clientSocket; 3.创建socket并指定代理对象为self,代理队列必须为主队列.1self.clientSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()]; 4.连接指定主机的对应端口.12NSError *error = nil;self.connected = [self.clientSocket connectToHost:self.addressTF.text onPort:[self.portTF.text integerValue] viaInterface:nil withTimeout:-1 error:&amp;error]; 5.成功连接主机对应端口号.123456789101112- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port &#123;// NSLog(@"连接主机对应端口%@", sock); [self showMessageWithStr:@"链接成功"]; [self showMessageWithStr:[NSString stringWithFormat:@"服务器IP: %@-------端口: %d", host,port]]; // 连接成功开启定时器 [self addTimer]; // 连接后,可读取服务端的数据 [self.clientSocket readDataWithTimeout:- 1 tag:0]; self.connected = YES;&#125; 注意:The host parameter will be an IP address, not a DNS name. – 引自GCDAsyncSocket连接的主机为IP地址,并非DNS名称. 6.发送数据给服务端12345678// 发送数据- (IBAction)sendMessageAction:(id)sender&#123; NSData *data = [self.messageTextF.text dataUsingEncoding:NSUTF8StringEncoding]; // withTimeout -1 : 无穷大,一直等 // tag : 消息标记 [self.clientSocket writeData:data withTimeout:- 1 tag:0];&#125; 注意:发送数据主要通过- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag写入数据的. 7.读取服务端数据1234567891011121314/** 读取数据 @param sock 客户端socket @param data 读取到的数据 @param tag 本次读取的标记 */- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123; NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showMessageWithStr:text]; // 读取到服务端数据值后,能再次读取 [self.clientSocket readDataWithTimeout:- 1 tag:0];&#125; 注意:有的人写好代码,而且第一次能够读取到数据,之后,再也接收不到数据.那是因为,在读取到数据的代理方法中,需要再次调用[self.clientSocket readDataWithTimeout:- 1 tag:0];方法,框架本身就是这么设计的. 8.客户端socket断开连接.1234567891011121314/** 客户端socket断开 @param sock 客户端socket @param err 错误描述 */- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err&#123; [self showMessageWithStr:@"断开连接"]; self.clientSocket.delegate = nil; self.clientSocket = nil; self.connected = NO; [self.connectTimer invalidate];&#125; 注意:sokect断开连接时,需要清空代理和客户端本身的socket.12self.clientSocket.delegate = nil;self.clientSocket = nil; 9.建立心跳连接.1234567891011121314151617181920212223 // 计时器@property (nonatomic, strong) NSTimer *connectTimer;// 添加定时器- (void)addTimer&#123; // 长连接定时器 self.connectTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(longConnectToSocket) userInfo:nil repeats:YES]; // 把定时器添加到当前运行循环,并且调为通用模式 [[NSRunLoop currentRunLoop] addTimer:self.connectTimer forMode:NSRunLoopCommonModes];&#125;// 心跳连接- (void)longConnectToSocket&#123; // 发送固定格式的数据,指令@"longConnect" float version = [[UIDevice currentDevice] systemVersion].floatValue; NSString *longConnect = [NSString stringWithFormat:@"123%f",version]; NSData *data = [longConnect dataUsingEncoding:NSUTF8StringEncoding]; [self.clientSocket writeData:data withTimeout:- 1 tag:0];&#125; 注意:心跳连接中发送给服务端的数据只是作为测试代码,根据你们公司需求,或者和后台商定好心跳包的数据以及发送心跳的时间间隔.因为这个项目的服务端socket也是我写的,所以,我自定义心跳包协议.客户端发送心跳包,服务端也需要有对应的心跳检测,以此检测客户端是否在线. 四.服务端步骤:1.继承GCDAsyncSocketDelegate协议.2.声明属性12// 服务端socket(开放端口,监听客户端socket的连接)@property (strong, nonatomic) GCDAsyncSocket *serverSocket; 3.创建socket并指定代理对象为self,代理队列必须为主队列.12// 初始化服务端socketself.serverSocket = [[GCDAsyncSocket alloc]initWithDelegate:self delegateQueue:dispatch_get_main_queue()]; 4.开放服务端的指定端口.1BOOL result = [self.serverSocket acceptOnPort:[self.portF.text integerValue] error:&amp;error]; 5.连接上新的客户端socket12345678910111213// 连接上新的客户端socket- (void)socket:(GCDAsyncSocket *)sock didAcceptNewSocket:(nonnull GCDAsyncSocket *)newSocket&#123; // 保存客户端的socket [self.clientSockets addObject: newSocket]; // 添加定时器 [self addTimer]; [self showMessageWithStr:@"链接成功"]; [self showMessageWithStr:[NSString stringWithFormat:@"客户端的地址: %@ -------端口: %d", newSocket.connectedHost, newSocket.connectedPort]]; [newSocket readDataWithTimeout:- 1 tag:0];&#125; 6.发送数据给客户端1234567891011// socket是保存的客户端socket, 表示给这个客户端socket发送消息- (IBAction)sendMessage:(id)sender&#123; if(self.clientSockets == nil) return; NSData *data = [self.messageTextF.text dataUsingEncoding:NSUTF8StringEncoding]; // withTimeout -1 : 无穷大,一直等 // tag : 消息标记 [self.clientSockets enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj writeData:data withTimeout:-1 tag:0]; &#125;];&#125; 7.读取客户端的数据123456789101112131415161718192021222324252627/** 读取客户端发送的数据 @param sock 客户端的Socket @param data 客户端发送的数据 @param tag 当前读取的标记 */- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag&#123; NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showMessageWithStr:text]; // 第一次读取到的数据直接添加 if (self.clientPhoneTimeDicts.count == 0) &#123; [self.clientPhoneTimeDicts setObject:[self getCurrentTime] forKey:text]; &#125; else &#123; // 键相同,直接覆盖,值改变 [self.clientPhoneTimeDicts enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; [self.clientPhoneTimeDicts setObject:[self getCurrentTime] forKey:text]; &#125;]; &#125; [sock readDataWithTimeout:- 1 tag:0];&#125; 8.建立检测心跳连接.12345678910111213141516171819202122232425262728293031// 检测心跳计时器@property (nonatomic, strong) NSTimer *checkTimer;// 添加计时器- (void)addTimer&#123; // 长连接定时器 self.checkTimer = [NSTimer scheduledTimerWithTimeInterval:10.0 target:self selector:@selector(checkLongConnect) userInfo:nil repeats:YES]; // 把定时器添加到当前运行循环,并且调为通用模式 [[NSRunLoop currentRunLoop] addTimer:self.checkTimer forMode:NSRunLoopCommonModes];&#125;// 检测心跳- (void)checkLongConnect&#123; [self.clientPhoneTimeDicts enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 获取当前时间 NSString *currentTimeStr = [self getCurrentTime]; // 延迟超过10秒判断断开 if (([currentTimeStr doubleValue] - [obj doubleValue]) &gt; 10.0) &#123; [self showMessageWithStr:[NSString stringWithFormat:@"%@已经断开,连接时差%f",key,[currentTimeStr doubleValue] - [obj doubleValue]]]; [self showMessageWithStr:[NSString stringWithFormat:@"移除%@",key]]; [self.clientPhoneTimeDicts removeObjectForKey:key]; &#125; else &#123; [self showMessageWithStr:[NSString stringWithFormat:@"%@处于连接状态,连接时差%f",key,[currentTimeStr doubleValue] - [obj doubleValue]]]; &#125; &#125;];&#125; 心跳检测方法只提供部分思路:1.懒加载一个可变字典,字典的键作为客户端的标识.如:客户端标识为13123456789. 2.在- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag方法中,将读取到的数据或者数据中的部分字符串作为键.字典的值为系统当前时间.服务端第一次读取数据时,字典中没有数据,所以,直接添加到可变字典中,之后每次读取数据时,都用字典的setObject: forKey:方法添加字典,若存储的键相同,即客户端标识相同,键会被覆盖,再使用系统的当前时间作为值. 3.在- (void)checkLongConnect中,获取此时的当前时间,遍历字典,将每个键的值和当前时间进行比较即可.判断的延迟时间可以写8秒.时间自定.之后,再根据自己的需求进行后续处理. 五.数据粘包处理.1.粘包情况.例如:包数据为:abcd. 接收类型 第1次接收 第2次接收 第3次接收 完整型 abcd abcdabcd abcdabcdabcd 多余型 abcdab cdabcdab cdabcdabcdab 不完整型 ab cda bcdabc 2.粘包解决思路.思路1:发送方将数据包加上包头和包尾,包头、包体以及包尾用字典形式包装成json字符串,接收方,通过解析获取json字符串中的包体,便可进行进一步处理.例如:1234567&#123;// head:包头,body:包体,end:包尾 NSDictionary *dict = @&#123; @"head" : @"phoneNum", @"body" : @(13133334444), @"end" : @(11)&#125;; &#125; 思路2:添加前缀.和包内容拼接成同一个字符串. 例如:当发送数据是13133334444,如果出现粘包情况只属于完整型:131333344441313333444413133334444131333344441313333444413133334444…可以将ab作为前缀.则接收到的数据出现的粘包情况:ab13133334444ab13133334444ab13133334444ab13133334444ab13133334444ab13133334444…使用componentsSeparatedByString:方法,以ab为分隔符,将每个包内容存入数组中,再取对应数组中的数据操作即可. 思路3:如果最终要得到的数据的长度是个固定长度,用一个字符串作为缓冲池,每次收到数据,都用字符串拼接对应数据,每当字符串的长度和固定长度相同时,便得到一个完整数据,处理完这个数据并清空字符串,再进行下一轮的字符拼接. 例如:处理上面的不完整型.创建一个长度是4的tempData字符串作为数据缓冲池.第1次收到数据,数据是:ab,tempData拼接上ab,tempData中只能再存储2个字符,第2次收到数据,将数据长度和2进行比较,第2次的数据是:cda,截取前两位字符,即cd,tempData继续拼接cd,此时,tempData为abcd,就是我们想要的数据,我们可以处理这个数据,处理之后并清空tempData,将第2次收到数据的剩余数据,即cda中的a,再与tempData拼接.之后,再进行类似操作. 核心代码123456789101112131415161718192021222324252627282930313233343536/** 处理数据粘包 @param readData 读取到的数据 */ - (void)dealStickPackageWithData:(NSString *)readData&#123; // 缓冲池还需要存储的数据个数 NSInteger tempCount; if (readData.length &gt; 0) &#123; // 还差tempLength个数填满缓冲池 tempCount = 4 - self.tempData.length; if (readData.length &lt;= tempCount) &#123; self.tempData = [self.tempData stringByAppendingString:readData]; if (self.tempData.length == 4) &#123; [self.mutArr addObject:self.tempData]; self.tempData = @""; &#125; &#125; else &#123; // 下一次的数据个数比要填满缓冲池的数据个数多,一定能拼接成完整数据,剩余的继续 self.tempData = [self.tempData stringByAppendingString:[readData substringToIndex:tempCount]]; [self.mutArr addObject:self.tempData]; self.tempData = @""; // 多余的再执行一次方法 [self dealStickPackageWithData:[readData substringFromIndex:tempCount]]; &#125; &#125;&#125; 调用12345678910111213141516171819202122// 存储处理后的每次返回数据@property (nonatomic, strong) NSMutableArray *mutArr;// 数据缓冲池@property (nonatomic, copy) NSString *tempData; /** 第四次测试 -- 混合型**/ self.mutArr = nil; /* 第1次 : abc 第2次 : da 第3次 : bcdabcd 第4次 : abcdabcd 第5次 : abcdabcdab */ // 数组中的数据代表每次接收的数据 NSArray *testArr4 = [NSArray arrayWithObjects:@"abc",@"da",@"bcdabcd",@"abcdabcd",@"abcdabcdab", nil]; self.tempData = @""; for (NSInteger i = 0; i &lt; testArr4.count; i++) &#123; [self dealStickPackageWithData:testArr4[i]]; &#125; NSLog(@"testArr4 = %@",self.mutArr); 结果:1234567892017-06-09 00:49:12.932976+0800 StickPackageDealDemo[10063:3430118] testArr4 = ( abcd, abcd, abcd, abcd, abcd, abcd, abcd) 数据粘包处理Demo在文末. 六.测试.1.测试配置.测试时,两端需要处于同一WiFi下.客户端中的IP地址为服务端的IP地址,具体信息进入Wifi设置中查看. 2.测试所需环境.将客户端程序安装在每个客户端,让一台服务端测试机和一台客户端测试机连接mac并运行,这两台测试机可以看到打印结果,所有由服务端发送到客户端的数据,通过客户端再回传给服务端,在服务端看打印结果. 3.进行延迟差测试.延迟差即服务端发送数据到第一台客户端和服务端发送数据到最后一台客户端的时间差.根据服务端发送数据给不同数量的客户端进行测试.而且,发送数据时,是随机发送. 延迟差测试结果: 由图所知,延迟差在200毫秒以内的比例基本保持在99%以上.所以符合开发需求(延迟在200毫秒以内). 4.单次信息收发测试.让服务端给每个客户端随机发送200次数据.并计算服务端发送数据到某一客户端,完整的一次收发时间情况. 单次信息收发测试结果: 由图所知,一次收发时间基本在95%以上,这个时间会根据网络状态和数据包大小波动.不过,可以直观看到数据从服务端到客户端的时间. GitHub:数据粘包处理DemoCocoaAsyncSocket客户端DemoCocoaAsyncSocket服务端DemoCocoaAsyncSocket客户端Demo(含粘包解决和测试)CocoaAsyncSocket服务端Demo(含粘包解决和测试)]]></content>
      <categories>
        <category>iOS第三方使用</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaAsyncSocket</tag>
        <tag>TCP</tag>
        <tag>粘包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之类型转换]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[本文介绍了常见的类型转换. 一.NSString和NSData的互相转换.NSString 转 NSData.123NSString *testStr1 = @"better";NSData *testData1 = [testStr1 dataUsingEncoding:NSUTF8StringEncoding];NSLog(@"testData:%@",testData1); 结果:12017-06-06 17:37:44.950912+0800 test1[9204:3141182] testData:&lt;62657474 6572&gt; NSData 转 NSString.12NSString *testStr2 = [[NSString alloc] initWithData:testData1 encoding:NSUTF8StringEncoding];NSLog(@"testStr:%@",testStr2); 结果:12017-06-06 17:37:44.951103+0800 test1[9204:3141182] testStr:better 二.NSData和Byte互相转换.NSData 转 Byte数组.1234567NSString *testStr3 = @"better";NSData *testData2 = [testStr3 dataUsingEncoding: NSUTF8StringEncoding];Byte *testByte1 = (Byte *)[testData2 bytes];for (int i = 0; i &lt; [testData2 length]; i++)&#123; NSLog(@"%d",testByte1[i]);&#125; 结果:1234562017-06-06 17:37:44.951213+0800 test1[9204:3141182] 982017-06-06 17:37:44.951250+0800 test1[9204:3141182] 1012017-06-06 17:37:44.951283+0800 test1[9204:3141182] 1162017-06-06 17:37:44.951314+0800 test1[9204:3141182] 1162017-06-06 17:37:44.951345+0800 test1[9204:3141182] 1012017-06-06 17:37:44.951376+0800 test1[9204:3141182] 114 说明:NSData默认含有bytes的只读属性,可直接调用.1@property (readonly) const void *bytes NS_RETURNS_INNER_POINTER; Byte数组 转 NSData.123Byte byteArr[] = &#123;98,101,116,116,101,114&#125;;NSData *testData3 = [[NSData alloc] initWithBytes:byteArr length:sizeof(byteArr)/sizeof(Byte)];NSLog(@"%@",testData3); 结果:12017-06-06 17:44:21.302122+0800 test1[9209:3143384] &lt;62657474 6572&gt; 三. 十六进制和十进制互相转换.十六进制 转 十进制 (系统方法)12NSUInteger testData4 = strtoul([testHexStr UTF8String],0,16);NSLog(@"%zd",testData4); 结果:12017-06-06 18:22:00.746316+0800 test1[9286:3154681] 190 strtoul说明:1234//参数1：字符串起始地址.//参数2：返回字符串有效数字的结束地址,这也是为什么要用二级指针的原因.//参数3：转换基数.当base=0,自动判断字符串的类型,并按10进制输出.strtoul(const char *__str, char **__endptr, int __base); 十进制 转 十六进制 (系统方法)12NSString *testHexStr = [NSString stringWithFormat:@"%@",[[NSString alloc] initWithFormat:@"%x",190]];NSLog(@"%@",testHexStr); 结果:12017-06-06 18:22:00.746256+0800 test1[9286:3154681] be 说明:转换结果不带0X前缀,如果需要带0X前缀,且是小写字母,使用%#x打印格式,若是大写字母,使用%#X打印格式. 十六进制 转 十进制 (自己实现 – 出自之类型转换)1234567891011121314151617181920212223242526272829303132// 十六进制转十进制 - (NSString *)convertDecimalWithHexStr:(NSString *)hexStr&#123; int decimal = 0; UniChar hexChar = ' '; NSInteger hexLength = [hexStr length]; for (NSInteger i = 0; i &lt; hexLength; i++) &#123; int base; hexChar = [hexStr characterAtIndex:i]; if (hexChar &gt;= '0' &amp;&amp; hexChar &lt;= '9') &#123; // 0 的Ascll - 48 base = (hexChar - 48); &#125; else if (hexChar &gt;= 'A' &amp;&amp; hexChar &lt;= 'F') &#123; // A 的Ascll - 65 base = (hexChar - 55); &#125; else &#123; // a 的Ascll - 97 base = (hexChar - 87); &#125; decimal = decimal + base * pow(16, hexLength - i - 1); &#125; return [NSString stringWithFormat:@"%d",decimal];&#125; 调用:1NSLog(@"%@",[self convertDecimalWithHexStr:@"AbCdE"]); 结果:12017-06-07 00:59:06.852111+0800 十六进制转十进制[9450:3194324] 703710 十进制 转 十六进制 (自己实现 – 出自之类型转换)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 十进制转十六进制- (NSString *)convertHexStrWithDecimal:(NSInteger)decimal&#123; NSMutableString *HexStr = [NSMutableString string]; NSString *currentStr = [NSString string]; // 余数 NSInteger remainder = 0; // 商 NSInteger quotient = 0; do &#123; // 余数 remainder = decimal % 16; quotient = decimal / 16; switch (remainder) &#123; case 10: currentStr = @"a"; break; case 11: currentStr = @"b"; break; case 12: currentStr = @"c"; break; case 13: currentStr = @"d"; break; case 14: currentStr = @"e"; break; case 15: currentStr = @"f"; break; default: currentStr = [NSString stringWithFormat:@"%zd",remainder]; break; &#125; // 将获得的字符串插入第一个位置 [HexStr insertString:currentStr atIndex:0]; // 将商作为新的计算值. decimal = quotient; &#125; while (quotient != 0); return HexStr;&#125; 调用:1NSLog(@"%@",[self convertHexStrWithDecimal:703710]); 结果:12017-06-07 00:59:06.851867+0800 十六进制转十进制[9450:3194324] abcde GitHub:iOS类型转换TypeConvertDemo]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之hos配置]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8Bhost%E9%85%8D%E7%BD%AE(Mac)%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之NSAttributedString使用]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20NSAttributedString%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之App上架流程(2017)]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BApp%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B(2017)%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown之简书书写换行代码缩进]]></title>
    <url>%2F2017%2F06%2F06%2FMarkdown%E4%B9%8B%E7%AE%80%E4%B9%A6%E4%B9%A6%E5%86%99%E6%8D%A2%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[本文介绍了简书书写换行代码缩进的方法.初次使用简书的富文本写技术类的文章时,容易出现换行代码块错乱的问题. 一.单纯的换行.代码块上的标题没有以下格式. 注意:圆点由-、*、+等产生. 简书代码: 显示效果: 二.标题带有圆点格式换行.代码块上的标题含有以下格式. 简书代码: 显示效果: 三.解决.使用tab键将以下各行向右缩进一个单位. 显示效果: 提示:多尝试,多摸索,你会发现,只要用tab键将int b = 1;所在行向右缩进一个单位即可.如果复制的代码来源中,本身带有空行的,在简书中可以自动显示为空行,而不需要调格式. 四.文本段落需要带有大于号(&gt;)的时候.简书代码: 显示效果: 五.解决.每行首个字符前加上&gt;号. 简书代码: 显示效果: 再用tab键从&gt;之后将int b = 0所在行向右缩进一个单位. 简书代码: 显示效果: 提示:多尝试,多摸索,你会发现,只要在int b = 1;所在行添加&gt;,之后从&gt;后面向右缩进一个单位即可.]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>简书</tag>
        <tag>缩进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之蓝牙使用]]></title>
    <url>%2F2017%2F05%2F16%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%93%9D%E7%89%99%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了蓝牙的简单使用 一.蓝牙概念蓝牙2.0为传统蓝牙,传统蓝牙也称为经典蓝牙.蓝牙4.0因为低耗电,所以也叫做低功耗蓝(BLE).它将三种规格集一体，包括传统蓝牙技术、高速技术和低耗能技术. 二.BLE支持两种部署方式1. 双模式低功耗蓝牙功能集成在现有的经典蓝牙控制器中，或在现有经典蓝牙技术芯片上增加低功耗堆栈，整体架构基本不变，因此成本增加有限. 2. 单模式面向高度集成、紧凑的设备，使用一个轻量级连接层(Link Layer)提供超低功耗的待机模式操作、简单设备恢复和可靠的点对多点数据传输，还能让联网传感器在蓝牙传输中安排好低功耗蓝牙流量的次序，同时还有高级节能和安全加密连接. 三.蓝牙各版本使用选择1. 蓝牙2.0,不上架使用私有API,手机需要越狱. 2. 蓝牙2.0,要上架进行MFI认证,使用ExternalAccessory框架.手机不需要越狱. 3. 蓝牙4.0,要上架使用CoreBluetooth框架,手机不需要越狱.(CoreBluetooth是基于BLE来开发的) 4. 说明对于小的硬件厂商来说,MFI认证通过几率不大,不仅耗钱还耗时,所以,还是推荐使用蓝牙4.0.(MFI:Make for ipad ,iphone, itouch 专们为苹果设备制作的设备) 四.问题描述公司要求iOS端需要和钢琴进行蓝牙连接并进行数据通信,我以为钢琴是蓝牙4.0,然后快速集成CoreBluetooth框架写了一个demo,扫描外设时,没有发现钢琴的蓝牙名称,可是用iphone打开系统设置,可以发现钢琴对应的蓝牙.问了安卓的同事,得知钢琴的蓝牙只有2.0的模块,所以,安卓端是用2.0蓝牙进行交互的.公司决定不做MFI认证,改用蓝牙4.0.在与硬件厂商交涉的过程中,得知钢琴中的蓝牙是4.0的,但是,他们在设计蓝牙板子的时候,没有集成低功耗技术.之后,板子寄回硬件厂商,添加BLE模块.这才踏上蓝牙4.0的正轨. 五.蓝牙4.0使用解析1.基本知识central:中心,连接硬件的设备.peripheral:外设,被连接的硬件.说明:外设在一直广播,当你创建的中心对象在扫描外设时,就能够发现外设.如图所示:service:服务.characteristic:特征.说明:一个外设包含多个服务,而每一个服务中又包含多个特征,特征包括特征的值和特征的描述.每个服务包含多个字段,字段的权限有read(读)、write(写)、notify(通知). 2.蓝牙4.0分为两种模式中心模式流程 建立中心角色 [[CBCentralManager alloc] initWithDelegate:self queue:nil] 扫描外设 cancelPeripheralConnection 发现外设 didDiscoverPeripheral 连接外设 connectPeripheral4.1 连接失败 didFailToConnectPeripheral4.2 连接断开 didDisconnectPeripheral4.3 连接成功 didConnectPeripheral 扫描外设中的服务 discoverServices5.1 发现并获取外设中的服务 didDiscoverServices 扫描外设对应服务的特征 discoverCharacteristics6.1 发现并获取外设对应服务的特征 didDiscoverCharacteristicsForService6.2 给对应特征写数据 writeValue:forCharacteristic:type: 订阅特征的通知 setNotifyValue:forCharacteristic:7.1 根据特征读取数据 didUpdateValueForCharacteristic 外设模式流程 建立外设角色 设置本地外设的服务和特征 发布外设和特征 广播服务 响应中心的读写请求 发送更新的特征值，订阅中心 六.蓝牙4.0开发步骤1.本文采用中心模式导入CoreBluetooth框架,#import &lt;CoreBluetooth/CoreBluetooth.h&gt; 2.遵守CBCentralManagerDelegate,CBPeripheralDelegate协议3.添加属性12345678910// 中心管理者(管理设备的扫描和连接)@property (nonatomic, strong) CBCentralManager *centralManager;// 存储的设备@property (nonatomic, strong) NSMutableArray *peripherals;// 扫描到的设备@property (nonatomic, strong) CBPeripheral *cbPeripheral;// 文本@property (weak, nonatomic) IBOutlet UITextView *peripheralText;// 外设状态@property (nonatomic, assign) CBManagerState peripheralState; 常量,具体服务和特征是读还是写的类型,问公司硬件厂商,或者问同事.12345678910// 蓝牙4.0设备名static NSString * const kBlePeripheralName = @"公司硬件蓝牙名称";// 通知服务static NSString * const kNotifyServerUUID = @"FFE0";// 写服务static NSString * const kWriteServerUUID = @"FFE1";// 通知特征值static NSString * const kNotifyCharacteristicUUID = @"FFE2";// 写特征值static NSString * const kWriteCharacteristicUUID = @"FFE3"; 4.创建中心管理者12345678- (CBCentralManager *)centralManager&#123; if (!_centralManager) &#123; _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; &#125; return _centralManager;&#125; 创建存储设备数组1234567- (NSMutableArray *)peripherals&#123; if (!_peripherals) &#123; _peripherals = [NSMutableArray array]; &#125; return _peripherals;&#125; 5.扫描设备之前会调用中心管理者状态改变的方法12345678910111213141516171819202122232425262728293031323334353637383940414243// 当状态更新时调用(如果不实现会崩溃)- (void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; switch (central.state) &#123; case CBManagerStateUnknown:&#123; NSLog(@"未知状态"); self.peripheralState = central.state; &#125; break; case CBManagerStateResetting: &#123; NSLog(@"重置状态"); self.peripheralState = central.state; &#125; break; case CBManagerStateUnsupported: &#123; NSLog(@"不支持的状态"); self.peripheralState = central.state; &#125; break; case CBManagerStateUnauthorized: &#123; NSLog(@"未授权的状态"); self.peripheralState = central.state; &#125; break; case CBManagerStatePoweredOff: &#123; NSLog(@"关闭状态"); self.peripheralState = central.state; &#125; break; case CBManagerStatePoweredOn: &#123; NSLog(@"开启状态－可用状态"); self.peripheralState = central.state; &#125; break; default: break; &#125;&#125; 扫描设备123456789101112// 扫描设备- (IBAction)scanForPeripherals&#123; [self.centralManager stopScan]; NSLog(@"扫描设备"); [self showMessage:@"扫描设备"]; if (self.peripheralState == CBManagerStatePoweredOn) &#123; // 扫描所有设备,传入nil,代表所有设备. [self.centralManager scanForPeripheralsWithServices:nil options:nil]; &#125;&#125; 6.扫描到设备并开始连接12345678910111213141516171819202122232425262728/** 扫描到设备 @param central 中心管理者 @param peripheral 扫描到的设备 @param advertisementData 广告信息 @param RSSI 信号强度 */- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; [self showMessage:[NSString stringWithFormat:@"发现设备,设备名:%@",peripheral.name]]; if (![self.peripherals containsObject:peripheral]) &#123; [self.peripherals addObject:peripheral]; NSLog(@"%@",peripheral); if ([peripheral.name isEqualToString:kBlePeripheralName]) &#123; [self showMessage:[NSString stringWithFormat:@"设备名:%@",peripheral.name]]; self.cbPeripheral = peripheral; [self showMessage:@"开始连接"]; [self.centralManager connectPeripheral:peripheral options:nil]; &#125; &#125;&#125; 7.连接的三种状态,如果连接成功,则扫描所有服务(也可以扫描指定服务)连接失败重连123456789101112131415/** 连接失败 @param central 中心管理者 @param peripheral 连接失败的设备 @param error 错误信息 */- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; [self showMessage:@"连接失败"]; if ([peripheral.name isEqualToString:kBlePeripheralName]) &#123; [self.centralManager connectPeripheral:peripheral options:nil]; &#125;&#125; 连接断开重连123456789101112131415/** 连接断开 @param central 中心管理者 @param peripheral 连接断开的设备 @param error 错误信息 */- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; [self showMessage:@"断开连接"]; if ([peripheral.name isEqualToString:kBlePeripheralName]) &#123; [self.centralManager connectPeripheral:peripheral options:nil]; &#125;&#125; 连接成功并扫描服务12345678910111213141516/** 连接成功 @param central 中心管理者 @param peripheral 连接成功的设备 */- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; NSLog(@"连接设备:%@成功",peripheral.name); [self showMessage:[NSString stringWithFormat:@"连接设备:%@成功",peripheral.name]]; // 设置设备的代理 peripheral.delegate = self; // services:传入nil代表扫描所有服务 [peripheral discoverServices:nil];&#125; 8.发现服务并扫描服务对应的特征1234567891011121314151617181920/** 扫描到服务 @param peripheral 服务对应的设备 @param error 扫描错误信息 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; // 遍历所有的服务 for (CBService *service in peripheral.services) &#123; NSLog(@"服务:%@",service.UUID.UUIDString); // 获取对应的服务 if ([service.UUID.UUIDString isEqualToString:kWriteServerUUID] || [service.UUID.UUIDString isEqualToString:kNotifyServerUUID]) &#123; // 根据服务去扫描特征 [peripheral discoverCharacteristics:nil forService:service]; &#125; &#125;&#125; 9.扫描到对应的特征,写入特征的值,并订阅指定的特征通知.1234567891011121314151617181920212223242526272829303132333435/** 扫描到对应的特征 @param peripheral 设备 @param service 特征对应的服务 @param error 错误信息 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; // 遍历所有的特征 for (CBCharacteristic *characteristic in service.characteristics) &#123; NSLog(@"特征值:%@",characteristic.UUID.UUIDString); // 获取对应的特征 if ([characteristic.UUID.UUIDString isEqualToString:kWriteCharacteristicUUID]) &#123; // 写入数据 [self showMessage:@"写入特征值"]; for (Byte i = 0x0; i &lt; 0x73; i++) &#123; // 让钢琴的每颗灯都亮一次 Byte byte[] = &#123;0xf0, 0x3d, 0x3d, i, 0x02,0xf7&#125;; NSData *data = [NSData dataWithBytes:byte length:6]; [peripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse]; &#125; &#125; if ([characteristic.UUID.UUIDString isEqualToString:kNotifyCharacteristicUUID]) &#123; // 订阅特征通知 [peripheral setNotifyValue:YES forCharacteristic:characteristic]; &#125; &#125;&#125; 10.根据特征读取到数据123456789101112131415/** 根据特征读到数据 @param peripheral 读取到数据对应的设备 @param characteristic 特征 @param error 错误信息 */- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(nonnull CBCharacteristic *)characteristic error:(nullable NSError *)error&#123; if ([characteristic.UUID.UUIDString isEqualToString:kNotifyCharacteristicUUID]) &#123; NSData *data = characteristic.value; NSLog(@"%@",data); &#125;&#125; 读取值打印结果:12342017-04-25 12:34:41.876974+0800 蓝牙4.0Demo[1745:346611] &lt;9f5436&gt;2017-04-25 12:34:41.983016+0800 蓝牙4.0Demo[1745:346611] &lt;8f5440&gt;2017-04-25 12:34:42.154821+0800 蓝牙4.0Demo[1745:346611] &lt;9f5649&gt;2017-04-25 12:34:42.239481+0800 蓝牙4.0Demo[1745:346611] &lt;8f5640&gt; 提示:上Appstore下载LightBlue,进行蓝牙通信测试. GitHub : 蓝牙4.0DemoCSDN : iOS开发之蓝牙使用]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之规范文档]]></title>
    <url>%2F2017%2F04%2F21%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[一.语言采用US(美式)英语,不使UK(英式)英语或汉字拼音.123US: UIColor *myColor =[UIColor blueColor];UK: UIColor *myColour =[UIColor blueColor];拼音: UIColor *wodeYanSe =[UIColor blueColor]; 二.命名规则1.常量的命名在前面加上小写字母k作为标记.其余遵循小驼峰命名法(第一个单词全部小写,后面单词首字母大写).1NSTimeInterval kAnimationDuration = 0.3; 2.宏的命名以两个大写字母作为前缀,后面遵循大驼峰命名法.12#define KKScreenWidth ([UIScreen mainScreen].bounds.size.width)#define KKAppVersion @"appVersion" 3.枚举的命名遵循Objective-C内部框架定义方式.Enum中枚举内容的命名需要以该Enum类型名称开头.1234567typedef NS_ENUM(NSInteger, FulowersMoveDestination)&#123; FulowersMoveDestinationTop, FulowersMoveDestinationBottom, FulowersMoveDestinationLeft, FulowersMoveDestinationRight,&#125;; 4.类的命名整体采用大驼峰式命名(每个单词的首字母大写).类前缀:采用开发者姓名的首字母大写.类后缀:采用对应类的全称.1234NavigationController 导航控制器: LBYNavigationControllerViewController 主页视图控制器: LBYHomeViewControllerTableViewController 表格控制器: LBYTableViewControllerTabBarController 标签控制器: LBYTabBarController 5.方法的命名当方法参数在三个以及三个以上,换行保持对齐(冒号对齐,冒号前是参数变量,冒号后是参数值).方法声明:12345+ (instancetype)initWithPersonName:(NSString *)name withAge:(int)age withSex:(NSString *)sex withHeight:(float)height withWeight:(float)weight; 方法调用:避免使用冒号对齐的方式. 6.属性和对象的命名采用修饰+类型的方式命名,BOOL类型添加is前缀,单词遵循小驼峰命名法.声明属性时,小括号中的顺序依次是:nonatomic,readonly,strong.12345@property (nonatomic, assign) BOOL isLogin;@property (nonatomic, weak) UITextField *loginNameTextField;@property (nonatomic, copy) NSString *studentClientName;@property (nonatomic, weak) UILabel *loginTipLabel;@property (nonatomic, weak) UIButton *loginButton; 三.注释注释是为了解释说明,方法或变量等命名规范合理,清楚易懂,可以不添加注释,含有复杂逻辑的代码必须添加注释.注释需要实时更新,跟随代码的变动进行更改或者删除. 1.公开类方法注释在.h文件中声明类方法,采用文档注释,要写明方法的具体作用,所有参数的含义以及返回的参数值.123456789101112131415/** 创建person对象的类方法 @param name 姓名 @param age 年龄 @param sex 性别 @param height 身高 @param weight 体重 @return 返回person类对象*/+ (instancetype)initWithPersonName:(NSString *)name withAge:(int)age withSex:(NSString *)sex withHeight:(float)height withWeight:(float)weight; 2.私有的对象方法注释在.m文件中实现对象方法,采用文档注释, 要写明方法的具体作用, 如果有参数和返回值,需要添加所有参数的含义以及返回的参数值.1234/** 搭建tableview的UI*/- (void)setupTableViewUI 3.方法内部逻辑代码注释复杂逻辑代码在代码上方进行注释,注释方式采用双斜杠+单个空格+具体注释内容123456789- (void)viewDidLoad&#123; [super ViewDidLoad]; // 注释 if(...) &#123; ... &#125; &#125; 4.属性注释1234/** 登陆按钮*/@property (nonatomic, weak) UIButton *loginBtn; 5.标记在函数分组和使用#pragma mark - 给重要逻辑代码添加标记,方便阅读1234567891011121314151617181920212223242526272829303132#pragma mark - Lifecycle- (instancetype)init - (void)dealloc - (void)viewDidLoad - (void)viewWillAppear:(BOOL)animated - (void)didReceiveMemoryWarning #pragma mark - IBActions- (IBAction)submitData:(id)sender #pragma mark - Public- (void)publicMethod #pragma mark - Private- (void)privateMethod #pragma mark - Custom Protocol- (void)tabbarBottomView:(LBYTabbarBottomView *)tabbarBottomView didSelectIndex:(NSUInteger)index didSelectBtn:(BYBottomButton *)selectBtn#pragma mark - UITextFieldDelegate- (void)textViewDidBeginEditing:(UITextView *)textView;- (void)textViewDidEndEditing:(UITextView *)textView; #pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; #pragma mark - UITableViewDelegate- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;#pragma mark - NSObject- (NSString *)description 6.打印关于NSLog,在项目或者SDK完成最终版本时,需要去掉打印的注释(可以使用pch预编译文件来禁止NSLog打印) 四.格式化1.赋值在”=”号左右两边各间隔一个空格.1static const int count = 0; 类方法或对象方法方法的”+/-”号和左侧小括号间隔一个空格,大括号换行,上下大括号对齐.1234- (void)viewDidLoad &#123;&#125; 2.属性声明property和左侧小括号间隔一个空格,逗号和下一个属性修饰符间隔一个空格,右侧小括号和属性类型间隔一个空格,属性类型和属性变量间隔一个空格.声明字符串类型时,NSString和号间隔一个空格,号和属性变量相连,应是*studentClientName```,不是```NSString* studentClientName```,也不是```NSString * studentClientName```.123```objc@property (nonatomic, assign, readwrite) BOOL isLogin;@property (nonatomic, copy, readwrite) NSString *studentClientName; 3.for循环for和左侧小括号间隔一个空格, i和”&lt;=”间隔一个空格, ”&lt;=”和”3”间隔一个空格, ”3”后面紧跟着封号 ,封号和i间隔一个空格.大括号换行,一对大括号上下位置对齐.1234for (int i = 0; i &lt;= 3; i++)&#123; // 语句&#125; 4.条件语句关于大括号,任何需要大括号的都不能省略.采用1234if (isLogin)&#123; return success;&#125; 不是12if (isLogin) return success; 也不是1if (isLogin) return success; 5.case语句当一个case语句包含多行代码时,大括号应该加上.如case 2所示.123456789101112131415161718switch (condition) &#123; case 1: // ... break; case 2: &#123; // ... // Multi-line example using braces break; &#125; case 3: // ... break; default: // ... break; &#125; 当在switch使用枚举类型时，default是不需要的.123456789101112131415switch (FulowersMoveDestination) &#123; case FulowersMoveDestinationTop: // ... break; case FulowersMoveDestinationBottom: // ... break; case FulowersMoveDestinationLeft: // ... break; case FulowersMoveDestinationRight: // ... break; &#125; 五.单例统一采用shared+类名作为单例类的方法名12345678910111213@implementation LBYNetworkTool+ (instancetype)sharedBYNetworkTool&#123; static LBYNetworkTool *instance; &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[LBYNetworkTool alloc]init]; &#125;); &#125; return instance;&#125;@end 六.UI整理搭建UI时,使用setup作为方法名前缀,将相应UI布局放在对应方法中123- (void)setupTableViewUI- (void)setupNavigationUI- (void)setupCollectionViewUI]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>规范文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS常见问题之苹果证书无法导出p12格式的文件]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B%E8%8B%B9%E6%9E%9C%E8%AF%81%E4%B9%A6%E6%97%A0%E6%B3%95%E5%AF%BC%E5%87%BAp12%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS常见问题</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Unity交互之界面跳转]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E5%92%8CUnity%E4%BA%A4%E4%BA%92%E4%B9%8B%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS和Unity交互</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
        <tag>iOS和Unity交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Unity交互之参数传递]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E5%92%8CUnity%E4%BA%A4%E4%BA%92%E4%B9%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[本文介绍了iOS和Unity交互,主要涉及参数的传递.(整个程序都处于Unity界面)调用方法一:Unity调方法传参,有返回值.Unity代码:123[DllImport("__Internal")]// 给iOS传string参数,有返回值,返回值通过iOS的return方法返回给Unityprivate static extern string getIPv6(string mHost, string mPort) iOS通过return方法,将值返回给UnityiOS代码:123456789101112/**获取IPv6的值,并返回给Unity @param mHost 主机名 @param mPort 端口号 @return IPv6值 */extern "C" const char *getIPv6(const char *mHost, const char *mPort)&#123; // strdup(const char *__s1) 复制mHost字符串,通过Malloc()进行空间分配 return strdup(mHost);&#125; 注意:1.如果Unity传参为string类型,不执行strdup()方法而使用return mHost方法,导致mHost没有分配内存空间而报错.报错信息:12skins(2509,0x1a8e5cb40) malloc: *** error for object 0x16fdc9114: pointer being freed was not allocated*** set a breakpoint in malloc_error_break to debug 2.如果Unity传参为int类型,可以使用return mHost方法.Unity代码:123[DllImport("__Internal")]// 给iOS传int参数,无返回值,返回值通过iOS的return方法返回给Unityprivate static extern int setMyInt(int date); iOS代码:12345// 返回int值extern "C" int setMyInt(int date)&#123; return date;&#125; 3.Unity方法中参数的变量名为date,在iOS中的extern “C” int setMyInt(int date)方法中设置的参数变量名可以与Unity的相同,设置为date,也可以是a、b、c等自定义参数变量,但是为了代码规范,尽量和Unity参数保持一致.4.调用DllImport(“”)方法,需要引入命名空间:using System.Runtime.InteropServices;5.extern “C”修饰的变量和函数是按照C语言方式编译和连接的. 调用方法二:Unity调方法传参,无返回值.Unity代码:1234// 传数据给iOS[DllImport("__Internal")]// 给iOS传string参数,无返回值,返回值通过iOS的UnitySendMessage方法返回给Unityprivate static extern void setDate(string date); 1234// 接收iOS的数据public void GetDate(string date)&#123;&#125; iOS调方法,传参给UnityiOS代码:1234567891011121314151617/** 返回Unity日期 @param date 日期 @return 无返回值 */extern "C" void setDate(const char *date)&#123; /** 发送数据给Unity @param obj 模型名 @param method Unity接收iOS数据的方法名 @param msg 传给Unity的数据 UnitySendMessage(const char* obj, const char* method, const char* msg); */ UnitySendMessage("PublicGameObject", "GetDate", date);&#125; 注意iOS通过UnitySendMessage方法返回数据给Unity时,需要传正确的date值,如果UnitySendMessage方法中的第三个参数不是将date作为参数,而是自定义的NSString类,需要做类型转换(Unity中的字符串为string,OC中的字符串为NSString)如下代码:12345extern "C" void setDate(const char *date)&#123; NSString *dateStr = @"Hello Word"; UnitySendMessage("PublicGameObject", "GetDate", [dateStr UTF8String]);&#125; 以下是全部代码Unity的.cs文件:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using UnityEngine;using System.Collections;using System.Runtime.InteropServices;using UnityEngine.UI;public class Iossdk : MonoBehaviour&#123; // getIPv6方法单独使用,setDate和GetDate配合使用 public InputField[] ips; [DllImport("__Internal")] // 给iOS传string参数,有返回值,返回值通过iOS的return方法返回给Unity private static extern string getIPv6(string mHost, string mPort) [DllImport("__Internal")] // 给iOS传string参数,无返回值,返回值通过iOS的UnitySendMessage方法返回给Unity private static extern void setDate(string date); [DllImport("__Internal")] // 给iOS传int参数,无返回值,返回值通过iOS的return方法返回给Unity private static extern int setMyInt(int date); // 传int参数给iOS public void SetMyInt() &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR int result = setMyInt(int.Parse(ips[1].text)); Debug.Log(result); #else Debug.Log(int.Parse(ips[1].text)); #endif &#125; // 传string参数给iOS public void SetDate() &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR setDate(ips[0].text); #else Debug.Log(ips[0].text); #endif &#125; // 接收iOS的数据 public void GetDate(string date) &#123; ips[1].text = date; Debug.Log(date); &#125; // 通过主机名和端口号获取IPv6 public static string GetIPv6(string mHost, string mPort) &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR string mIPv6 = getIPv6(mHost, mPort); return mIPv6; #else return mHost + " : " + mPort; #endif &#125; // 程序入口1 public void Click1() &#123; string s = GetIPv6(ips[0].text, ips[1].text); Debug.Log(s); &#125; // iOS程序入口2 public void Click2() &#123; SetDate(); &#125; // iOS程序入口3 public void Click3() &#123; SetMyInt(); &#125;&#125; iOS代码:.h文件12345#import &lt;Foundation/Foundation.h&gt;@interface IOSToUnity : NSObject@end .m文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import "IOSToUnity.h" @implementation IOSToUnity /** 获取IPv6的值,并返回给Unity @param mHost 主机名 @param mPort 端口号 @return IPv6值 */extern "C" const char * getIPv6(const char *mHost, const char *mPort)&#123; // strdup(const char *__s1) 复制mHost字符串,通过Malloc()进行空间分配 return strdup(mHost);&#125; /** 返回Unity日期 @param date 日期 @return 无返回值 */extern "C" void setDate(const char *date)&#123; /** 发送数据给Unity @param obj 模型名 @param method Unity接收iOS数据的方法名 @param msg 传给Unity的数据 UnitySendMessage(const char* obj, const char* method, const char* msg); */ UnitySendMessage("PublicGameObject", "GetDate", date);&#125; /** 返回int值 @param mHost 主机名 @return 主机名 */ extern "C" int setMyInt(int date) &#123; return date; &#125; @end 如果已经掌握本文参数传递的方法,不妨看下界面交互的部分.简书 : iOS和Unity交互之界面跳转]]></content>
      <categories>
        <category>iOS和Unity交互</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
        <tag>iOS和Unity交互</tag>
      </tags>
  </entry>
</search>