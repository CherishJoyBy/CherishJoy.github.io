<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B%E8%8B%B9%E6%9E%9C%E8%AF%81%E4%B9%A6%E6%97%A0%E6%B3%95%E5%AF%BC%E5%87%BAp12%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[###Welcome to use MarkDown]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%92%8CUnity%E4%BA%A4%E4%BA%92%E4%B9%8B%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[###Welcome to use MarkDown]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BApp%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B(2017)%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%8B%B9%E6%9E%9C%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%93%9D%E7%89%99%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20NSAttributedString%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8Bhost%E9%85%8D%E7%BD%AE(Mac)%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FMarkdown%E4%B9%8B%E7%AE%80%E4%B9%A6%E4%B9%A6%E5%86%99%E6%8D%A2%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建]]></title>
    <url>%2F2017%2F06%2F10%2FHexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开始安装1$ npm install -g hexo 出错,使用淘宝镜像1$ npm config set registry https://registry.npm.taobao.org 出现权限不允许,修改该文件的权限:/usr/local/lib/node_modules,找到文件夹右击,权限改为:读与写创建一个文件夹名为:Blog,cd到Blog文件夹中1$ cd /Users/lbymac/Blog 初始化hex1$ hexo init 文件生成1$ hexo generate 本地服务测试1$ hexo server 在_config.yml文件中添加以下信息123type: git repository: https://github.com/CherishJoyBy/CherishJoyBy.github.io.gitbranch: master git上传插件安装1$ npm install hexo-deployer-git —save 清空1$ hexo clean 生成1$ hexo generate 部署上传1$ hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之CocoaAsyncSocket使用]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BCocoaAsyncSocket%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了CocoaAsyncSocket库中GCDAsyncSocket类的使用、粘包处理以及时间延迟测试. 一.CocoaAsyncSocket介绍CocoaAsyncSocket中主要包含两个类: 1.GCDAsyncSocket. 用GCD搭建的基于TCP/IP协议的socket网络库GCDAsyncSocket is a TCP/IP socket networking library built atop Grand Central Dispatch. – 引自CocoaAsyncSocket. 2.GCDAsyncUdpSocket. 用GCD搭建的基于UDP/IP协议的socket网络库.GCDAsyncUdpSocket is a UDP/IP socket networking library built atop Grand Central Dispatch..– 引自CocoaAsyncSocket. 二.下载CocoaAsyncSocket首先,需要到这里下载CocoaAsyncSocket.下载后可以看到文件所在位置. 这里只要拷贝以下两个文件到项目中. 三.客户端因为,大部分项目已经有服务端socket,所以,先讲解客户端创建过程. 步骤:1.继承GCDAsyncSocketDelegate协议.2.声明属性12// 客户端socket@property (strong, nonatomic) GCDAsyncSocket *clientSocket; 3.创建socket并指定代理对象为self,代理队列必须为主队列.1self.clientSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()]; 4.连接指定主机的对应端口.12NSError *error = nil;self.connected = [self.clientSocket connectToHost:self.addressTF.text onPort:[self.portTF.text integerValue] viaInterface:nil withTimeout:-1 error:&amp;error]; 5.成功连接主机对应端口号.123456789101112- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port &#123;// NSLog(@"连接主机对应端口%@", sock); [self showMessageWithStr:@"链接成功"]; [self showMessageWithStr:[NSString stringWithFormat:@"服务器IP: %@-------端口: %d", host,port]]; // 连接成功开启定时器 [self addTimer]; // 连接后,可读取服务端的数据 [self.clientSocket readDataWithTimeout:- 1 tag:0]; self.connected = YES;&#125; 注意:The host parameter will be an IP address, not a DNS name. – 引自GCDAsyncSocket连接的主机为IP地址,并非DNS名称. 6.发送数据给服务端12345678// 发送数据- (IBAction)sendMessageAction:(id)sender&#123; NSData *data = [self.messageTextF.text dataUsingEncoding:NSUTF8StringEncoding]; // withTimeout -1 : 无穷大,一直等 // tag : 消息标记 [self.clientSocket writeData:data withTimeout:- 1 tag:0];&#125; 注意:发送数据主要通过- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag写入数据的. 7.读取服务端数据1234567891011121314/** 读取数据 @param sock 客户端socket @param data 读取到的数据 @param tag 本次读取的标记 */- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123; NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showMessageWithStr:text]; // 读取到服务端数据值后,能再次读取 [self.clientSocket readDataWithTimeout:- 1 tag:0];&#125; 注意:有的人写好代码,而且第一次能够读取到数据,之后,再也接收不到数据.那是因为,在读取到数据的代理方法中,需要再次调用[self.clientSocket readDataWithTimeout:- 1 tag:0];方法,框架本身就是这么设计的. 8.客户端socket断开连接.1234567891011121314/** 客户端socket断开 @param sock 客户端socket @param err 错误描述 */- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err&#123; [self showMessageWithStr:@"断开连接"]; self.clientSocket.delegate = nil; self.clientSocket = nil; self.connected = NO; [self.connectTimer invalidate];&#125; 注意:sokect断开连接时,需要清空代理和客户端本身的socket.12self.clientSocket.delegate = nil;self.clientSocket = nil; 9.建立心跳连接.1234567891011121314151617181920212223 // 计时器@property (nonatomic, strong) NSTimer *connectTimer;// 添加定时器- (void)addTimer&#123; // 长连接定时器 self.connectTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(longConnectToSocket) userInfo:nil repeats:YES]; // 把定时器添加到当前运行循环,并且调为通用模式 [[NSRunLoop currentRunLoop] addTimer:self.connectTimer forMode:NSRunLoopCommonModes];&#125;// 心跳连接- (void)longConnectToSocket&#123; // 发送固定格式的数据,指令@"longConnect" float version = [[UIDevice currentDevice] systemVersion].floatValue; NSString *longConnect = [NSString stringWithFormat:@"123%f",version]; NSData *data = [longConnect dataUsingEncoding:NSUTF8StringEncoding]; [self.clientSocket writeData:data withTimeout:- 1 tag:0];&#125; 注意:心跳连接中发送给服务端的数据只是作为测试代码,根据你们公司需求,或者和后台商定好心跳包的数据以及发送心跳的时间间隔.因为这个项目的服务端socket也是我写的,所以,我自定义心跳包协议.客户端发送心跳包,服务端也需要有对应的心跳检测,以此检测客户端是否在线. 四.服务端步骤:1.继承GCDAsyncSocketDelegate协议.2.声明属性12// 服务端socket(开放端口,监听客户端socket的连接)@property (strong, nonatomic) GCDAsyncSocket *serverSocket; 3.创建socket并指定代理对象为self,代理队列必须为主队列.12// 初始化服务端socketself.serverSocket = [[GCDAsyncSocket alloc]initWithDelegate:self delegateQueue:dispatch_get_main_queue()]; 4.开放服务端的指定端口.1BOOL result = [self.serverSocket acceptOnPort:[self.portF.text integerValue] error:&amp;error]; 5.连接上新的客户端socket12345678910111213// 连接上新的客户端socket- (void)socket:(GCDAsyncSocket *)sock didAcceptNewSocket:(nonnull GCDAsyncSocket *)newSocket&#123; // 保存客户端的socket [self.clientSockets addObject: newSocket]; // 添加定时器 [self addTimer]; [self showMessageWithStr:@"链接成功"]; [self showMessageWithStr:[NSString stringWithFormat:@"客户端的地址: %@ -------端口: %d", newSocket.connectedHost, newSocket.connectedPort]]; [newSocket readDataWithTimeout:- 1 tag:0];&#125; 6.发送数据给客户端1234567891011// socket是保存的客户端socket, 表示给这个客户端socket发送消息- (IBAction)sendMessage:(id)sender&#123; if(self.clientSockets == nil) return; NSData *data = [self.messageTextF.text dataUsingEncoding:NSUTF8StringEncoding]; // withTimeout -1 : 无穷大,一直等 // tag : 消息标记 [self.clientSockets enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj writeData:data withTimeout:-1 tag:0]; &#125;];&#125; 7.读取客户端的数据123456789101112131415161718192021222324252627/** 读取客户端发送的数据 @param sock 客户端的Socket @param data 客户端发送的数据 @param tag 当前读取的标记 */- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag&#123; NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showMessageWithStr:text]; // 第一次读取到的数据直接添加 if (self.clientPhoneTimeDicts.count == 0) &#123; [self.clientPhoneTimeDicts setObject:[self getCurrentTime] forKey:text]; &#125; else &#123; // 键相同,直接覆盖,值改变 [self.clientPhoneTimeDicts enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; [self.clientPhoneTimeDicts setObject:[self getCurrentTime] forKey:text]; &#125;]; &#125; [sock readDataWithTimeout:- 1 tag:0];&#125; 8.建立检测心跳连接.12345678910111213141516171819202122232425262728293031// 检测心跳计时器@property (nonatomic, strong) NSTimer *checkTimer;// 添加计时器- (void)addTimer&#123; // 长连接定时器 self.checkTimer = [NSTimer scheduledTimerWithTimeInterval:10.0 target:self selector:@selector(checkLongConnect) userInfo:nil repeats:YES]; // 把定时器添加到当前运行循环,并且调为通用模式 [[NSRunLoop currentRunLoop] addTimer:self.checkTimer forMode:NSRunLoopCommonModes];&#125;// 检测心跳- (void)checkLongConnect&#123; [self.clientPhoneTimeDicts enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 获取当前时间 NSString *currentTimeStr = [self getCurrentTime]; // 延迟超过10秒判断断开 if (([currentTimeStr doubleValue] - [obj doubleValue]) &gt; 10.0) &#123; [self showMessageWithStr:[NSString stringWithFormat:@"%@已经断开,连接时差%f",key,[currentTimeStr doubleValue] - [obj doubleValue]]]; [self showMessageWithStr:[NSString stringWithFormat:@"移除%@",key]]; [self.clientPhoneTimeDicts removeObjectForKey:key]; &#125; else &#123; [self showMessageWithStr:[NSString stringWithFormat:@"%@处于连接状态,连接时差%f",key,[currentTimeStr doubleValue] - [obj doubleValue]]]; &#125; &#125;];&#125; 心跳检测方法只提供部分思路:1.懒加载一个可变字典,字典的键作为客户端的标识.如:客户端标识为13123456789. 2.在- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag方法中,将读取到的数据或者数据中的部分字符串作为键.字典的值为系统当前时间.服务端第一次读取数据时,字典中没有数据,所以,直接添加到可变字典中,之后每次读取数据时,都用字典的setObject: forKey:方法添加字典,若存储的键相同,即客户端标识相同,键会被覆盖,再使用系统的当前时间作为值. 3.在- (void)checkLongConnect中,获取此时的当前时间,遍历字典,将每个键的值和当前时间进行比较即可.判断的延迟时间可以写8秒.时间自定.之后,再根据自己的需求进行后续处理. 五.数据粘包处理.1.粘包情况.例如:包数据为:abcd. 接收类型 第1次接收 第2次接收 第3次接收 完整型 abcd abcdabcd abcdabcdabcd 多余型 abcdab cdabcdab cdabcdabcdab 不完整型 ab cda bcdabc 2.粘包解决思路.思路1:发送方将数据包加上包头和包尾,包头、包体以及包尾用字典形式包装成json字符串,接收方,通过解析获取json字符串中的包体,便可进行进一步处理.例如:1234567&#123;// head:包头,body:包体,end:包尾 NSDictionary *dict = @&#123; @"head" : @"phoneNum", @"body" : @(13133334444), @"end" : @(11)&#125;; &#125; 思路2:添加前缀.和包内容拼接成同一个字符串. 例如:当发送数据是13133334444,如果出现粘包情况只属于完整型:131333344441313333444413133334444131333344441313333444413133334444…可以将ab作为前缀.则接收到的数据出现的粘包情况:ab13133334444ab13133334444ab13133334444ab13133334444ab13133334444ab13133334444…使用componentsSeparatedByString:方法,以ab为分隔符,将每个包内容存入数组中,再取对应数组中的数据操作即可. 思路3:如果最终要得到的数据的长度是个固定长度,用一个字符串作为缓冲池,每次收到数据,都用字符串拼接对应数据,每当字符串的长度和固定长度相同时,便得到一个完整数据,处理完这个数据并清空字符串,再进行下一轮的字符拼接. 例如:处理上面的不完整型.创建一个长度是4的tempData字符串作为数据缓冲池.第1次收到数据,数据是:ab,tempData拼接上ab,tempData中只能再存储2个字符,第2次收到数据,将数据长度和2进行比较,第2次的数据是:cda,截取前两位字符,即cd,tempData继续拼接cd,此时,tempData为abcd,就是我们想要的数据,我们可以处理这个数据,处理之后并清空tempData,将第2次收到数据的剩余数据,即cda中的a,再与tempData拼接.之后,再进行类似操作. 核心代码123456789101112131415161718192021222324252627282930313233343536/** 处理数据粘包 @param readData 读取到的数据 */ - (void)dealStickPackageWithData:(NSString *)readData&#123; // 缓冲池还需要存储的数据个数 NSInteger tempCount; if (readData.length &gt; 0) &#123; // 还差tempLength个数填满缓冲池 tempCount = 4 - self.tempData.length; if (readData.length &lt;= tempCount) &#123; self.tempData = [self.tempData stringByAppendingString:readData]; if (self.tempData.length == 4) &#123; [self.mutArr addObject:self.tempData]; self.tempData = @""; &#125; &#125; else &#123; // 下一次的数据个数比要填满缓冲池的数据个数多,一定能拼接成完整数据,剩余的继续 self.tempData = [self.tempData stringByAppendingString:[readData substringToIndex:tempCount]]; [self.mutArr addObject:self.tempData]; self.tempData = @""; // 多余的再执行一次方法 [self dealStickPackageWithData:[readData substringFromIndex:tempCount]]; &#125; &#125;&#125; 调用12345678910111213141516171819202122// 存储处理后的每次返回数据@property (nonatomic, strong) NSMutableArray *mutArr;// 数据缓冲池@property (nonatomic, copy) NSString *tempData; /** 第四次测试 -- 混合型**/ self.mutArr = nil; /* 第1次 : abc 第2次 : da 第3次 : bcdabcd 第4次 : abcdabcd 第5次 : abcdabcdab */ // 数组中的数据代表每次接收的数据 NSArray *testArr4 = [NSArray arrayWithObjects:@"abc",@"da",@"bcdabcd",@"abcdabcd",@"abcdabcdab", nil]; self.tempData = @""; for (NSInteger i = 0; i &lt; testArr4.count; i++) &#123; [self dealStickPackageWithData:testArr4[i]]; &#125; NSLog(@"testArr4 = %@",self.mutArr); 结果:1234567892017-06-09 00:49:12.932976+0800 StickPackageDealDemo[10063:3430118] testArr4 = ( abcd, abcd, abcd, abcd, abcd, abcd, abcd) 数据粘包处理Demo在文末. 六.测试.1.测试配置.测试时,两端需要处于同一WiFi下.客户端中的IP地址为服务端的IP地址,具体信息进入Wifi设置中查看. 2.测试所需环境.将客户端程序安装在每个客户端,让一台服务端测试机和一台客户端测试机连接mac并运行,这两台测试机可以看到打印结果,所有由服务端发送到客户端的数据,通过客户端再回传给服务端,在服务端看打印结果. 3.进行延迟差测试.延迟差即服务端发送数据到第一台客户端和服务端发送数据到最后一台客户端的时间差.根据服务端发送数据给不同数量的客户端进行测试.而且,发送数据时,是随机发送. 延迟差测试结果: 由图所知,延迟差在200毫秒以内的比例基本保持在99%以上.所以符合开发需求(延迟在200毫秒以内). 4.单次信息收发测试.让服务端给每个客户端随机发送200次数据.并计算服务端发送数据到某一客户端,完整的一次收发时间情况. 单次信息收发测试结果: 由图所知,一次收发时间基本在95%以上,这个时间会根据网络状态和数据包大小波动.不过,可以直观看到数据从服务端到客户端的时间. GitHub:数据粘包处理DemoCocoaAsyncSocket客户端DemoCocoaAsyncSocket服务端DemoCocoaAsyncSocket客户端Demo(含粘包解决和测试)CocoaAsyncSocket服务端Demo(含粘包解决和测试)]]></content>
      <categories>
        <category>iOS第三方使用</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaAsyncSocket</tag>
        <tag>TCP</tag>
        <tag>粘包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Unity交互之参数传递]]></title>
    <url>%2F2017%2F04%2F20%2FiOS%E5%92%8CUnity%E4%BA%A4%E4%BA%92%E4%B9%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[本文介绍了iOS和Unity交互,主要涉及参数的传递.(整个程序都处于Unity界面)调用方法一:Unity调方法传参,有返回值.Unity代码:123[DllImport("__Internal")]// 给iOS传string参数,有返回值,返回值通过iOS的return方法返回给Unityprivate static extern string getIPv6(string mHost, string mPort) iOS通过return方法,将值返回给UnityiOS代码:123456789101112/**获取IPv6的值,并返回给Unity @param mHost 主机名 @param mPort 端口号 @return IPv6值 */extern "C" const char *getIPv6(const char *mHost, const char *mPort)&#123; // strdup(const char *__s1) 复制mHost字符串,通过Malloc()进行空间分配 return strdup(mHost);&#125; 注意:1.如果Unity传参为string类型,不执行strdup()方法而使用return mHost方法,导致mHost没有分配内存空间而报错.报错信息:12skins(2509,0x1a8e5cb40) malloc: *** error for object 0x16fdc9114: pointer being freed was not allocated*** set a breakpoint in malloc_error_break to debug 2.如果Unity传参为int类型,可以使用return mHost方法.Unity代码:123[DllImport("__Internal")]// 给iOS传int参数,无返回值,返回值通过iOS的return方法返回给Unityprivate static extern int setMyInt(int date); iOS代码:12345// 返回int值extern "C" int setMyInt(int date)&#123; return date;&#125; 3.Unity方法中参数的变量名为date,在iOS中的extern “C” int setMyInt(int date)方法中设置的参数变量名可以与Unity的相同,设置为date,也可以是a、b、c等自定义参数变量,但是为了代码规范,尽量和Unity参数保持一致.4.调用DllImport(“”)方法,需要引入命名空间:using System.Runtime.InteropServices;5.extern “C”修饰的变量和函数是按照C语言方式编译和连接的. 调用方法二:Unity调方法传参,无返回值.Unity代码:1234// 传数据给iOS[DllImport("__Internal")]// 给iOS传string参数,无返回值,返回值通过iOS的UnitySendMessage方法返回给Unityprivate static extern void setDate(string date); 1234// 接收iOS的数据public void GetDate(string date)&#123;&#125; iOS调方法,传参给UnityiOS代码:1234567891011121314151617/** 返回Unity日期 @param date 日期 @return 无返回值 */extern "C" void setDate(const char *date)&#123; /** 发送数据给Unity @param obj 模型名 @param method Unity接收iOS数据的方法名 @param msg 传给Unity的数据 UnitySendMessage(const char* obj, const char* method, const char* msg); */ UnitySendMessage("PublicGameObject", "GetDate", date);&#125; 注意iOS通过UnitySendMessage方法返回数据给Unity时,需要传正确的date值,如果UnitySendMessage方法中的第三个参数不是将date作为参数,而是自定义的NSString类,需要做类型转换(Unity中的字符串为string,OC中的字符串为NSString)如下代码:12345extern "C" void setDate(const char *date)&#123; NSString *dateStr = @"Hello Word"; UnitySendMessage("PublicGameObject", "GetDate", [dateStr UTF8String]);&#125; 以下是全部代码Unity的.cs文件:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using UnityEngine;using System.Collections;using System.Runtime.InteropServices;using UnityEngine.UI;public class Iossdk : MonoBehaviour&#123; // getIPv6方法单独使用,setDate和GetDate配合使用 public InputField[] ips; [DllImport("__Internal")] // 给iOS传string参数,有返回值,返回值通过iOS的return方法返回给Unity private static extern string getIPv6(string mHost, string mPort) [DllImport("__Internal")] // 给iOS传string参数,无返回值,返回值通过iOS的UnitySendMessage方法返回给Unity private static extern void setDate(string date); [DllImport("__Internal")] // 给iOS传int参数,无返回值,返回值通过iOS的return方法返回给Unity private static extern int setMyInt(int date); // 传int参数给iOS public void SetMyInt() &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR int result = setMyInt(int.Parse(ips[1].text)); Debug.Log(result); #else Debug.Log(int.Parse(ips[1].text)); #endif &#125; // 传string参数给iOS public void SetDate() &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR setDate(ips[0].text); #else Debug.Log(ips[0].text); #endif &#125; // 接收iOS的数据 public void GetDate(string date) &#123; ips[1].text = date; Debug.Log(date); &#125; // 通过主机名和端口号获取IPv6 public static string GetIPv6(string mHost, string mPort) &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR string mIPv6 = getIPv6(mHost, mPort); return mIPv6; #else return mHost + " : " + mPort; #endif &#125; // 程序入口1 public void Click1() &#123; string s = GetIPv6(ips[0].text, ips[1].text); Debug.Log(s); &#125; // iOS程序入口2 public void Click2() &#123; SetDate(); &#125; // iOS程序入口3 public void Click3() &#123; SetMyInt(); &#125;&#125; iOS代码:.h文件12345#import &lt;Foundation/Foundation.h&gt;@interface IOSToUnity : NSObject@end .m文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import "IOSToUnity.h" @implementation IOSToUnity /** 获取IPv6的值,并返回给Unity @param mHost 主机名 @param mPort 端口号 @return IPv6值 */extern "C" const char * getIPv6(const char *mHost, const char *mPort)&#123; // strdup(const char *__s1) 复制mHost字符串,通过Malloc()进行空间分配 return strdup(mHost);&#125; /** 返回Unity日期 @param date 日期 @return 无返回值 */extern "C" void setDate(const char *date)&#123; /** 发送数据给Unity @param obj 模型名 @param method Unity接收iOS数据的方法名 @param msg 传给Unity的数据 UnitySendMessage(const char* obj, const char* method, const char* msg); */ UnitySendMessage("PublicGameObject", "GetDate", date);&#125; /** 返回int值 @param mHost 主机名 @return 主机名 */ extern "C" int setMyInt(int date) &#123; return date; &#125; @end 如果已经掌握本文参数传递的方法,不妨看下界面交互的部分.简书 : iOS和Unity交互之界面跳转]]></content>
      <categories>
        <category>iOS和Unity交互</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
        <tag>iOS和Unity交互</tag>
      </tags>
  </entry>
</search>