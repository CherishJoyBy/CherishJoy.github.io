<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java开发之Linux常用命令]]></title>
    <url>%2F2019%2F03%2F17%2FJava%E5%BC%80%E5%8F%91%E4%B9%8BLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文介绍了Linux的常用命令. 一.文件目录操作1.进入usr文件 1$ cd usr 2.返回上一层文件目录 1$ cd .. 3.切换到系统根目录cd ~ 1$ cd ~ 4.查询当前文件目录列表 1$ ls 5.创建usr目录 1$ mkdir usr 6.删除usr目录 1$ rmdir usr 7.删除a.txt文件 1$ rm a.txt 8.将a.txt文件重命名为b.txt 1$ mv a.txt b.txt 9.将a.txt文件复制到上一层目录中 1$ cp a.txt ../ 二.其他常用操作 端口占用时 1.查找8080端口PID 1$ netstat -anp | grep 8080 2.根据8080端口的PID杀死进程 1$ kill -9 pid 日志查询 3.查询12月3号14点到15点的日志，按空格键下一页 1$ sed -n &apos;/2021-12-03 14/,/2021-12-03 15/p&apos; boot-info-error.log | more 4.根据error关键字查询日志,按空格键下一页 1$ cat -n boot-info-error.log | grep &apos;error&apos; | more 使用CRT连接linux时，进入SFTP上传文件的界面 ：ALT+P 5.改变远程的文件夹路径为（/usr/local/project） 1$ cd /usr/local/project 6.改变本地的文件夹路径为（d:\var） 1$ lcd d:\\var 7.查看远程路径 1$ pwd 8.查看本地路径 1$ lpwd 9.上传文件 1$ put 文件名.xxx 10.下载文件（boot-info-error.log） 1$ get boot-info-error.log 11.查找路径/下名称含有tomcat的文件或文件夹 1$ sudo find / -name *tomcat* 12.查找tomcat的文件目录 1$ whereis tomcat 13.打jar包，关闭CRT窗口，保持服务持续有效不断线 1$ nohup java -jar xxx.jar &amp; 14.查看nohup.out实时日志打印信息 1$ tail -f nohup.out 15.查看boot-info-error.log最后100行日志信息 1$ tail -n 100 boot-info-error.log]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS读书笔记之Spring实战Part1(第4版)]]></title>
    <url>%2F2019%2F01%2F15%2FJava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BSpring%E5%AE%9E%E6%88%98Part1(%E7%AC%AC4%E7%89%88)%2F</url>
    <content type="text"><![CDATA[本文主要介绍了Spring的相关知识. 一.Spring的概念.Spring是一个开源框架,是为了解决企业应用开发的复杂性而创建.Spring的根本使命:简化Java开发.具体简化策略: 基于POJO的轻量级和最小侵入性编程. 通过依赖注入和面向接口实现松耦合. 基于切面和惯例进行声明式编程. 通过切面和模板减少样板式代码. 1.POJOPOJO(Plain Ordinary Java Object)是一个简单的普通的Java对象,它不包含业务逻辑或持久逻辑,不是JavaBean, EntityBean等.POJO不担当任何特殊的角色,也不实现任何特殊的Java框架的接口. 2.依赖注入 对象的依赖关系将有负责协调系统中各个对象的第三方组件在创建对象时设定,对象无需自行创建或管理他们的依赖关系,依赖关系将被自动注入到需要它们的对象中去. 组件不做定位查询,只提供普通的Java方法让容器去决定依赖关系.容器全权负责组件的装配，它会把符合依赖关系的对象通过JavaBean属性或者构造函数传递给需要的对象. 3.AOP通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术. 二.Spring的核心.容器是Spring框架的核心.Spring容器分为以下两种类型 bean工厂 应用上下文.(下面主要讲解通过应用上下文管理bean) 1.应用上下文Spring中自带的多种应用上下文,分别为: AnnotationConfigApplicationContext:从一个或多个基于Java的配置类中加载Spring应用上下文例子: 1ApplicationContext context = new AnnotationConfigApplicationContext(com.springinaction.knights.config.KnightConfig.class); AnnotationConfigWebApplicationContext:从一个或多个基于Java的配置类中加载Spring Web应用上下文 ClassPathXmlApplicationContext:从类路径下的一个或多个XML配置文件中加载上下文定义,把应用上下文的定义文件作为类资源.例子: 1ApplicationContext context = new ClassPathXmlApplicationContext(knight.xml); FileSystemXmlApplicationContext:从文件系统下的一个或多个XML配置文件中加载上下文定义例子: 1ApplicationContext context = new FileSystemXmlApplicationContext(c:/knight.xml); XmlWebApplicationContext:从Web应用下的一个或多个XML配置文件中加载上下文定义 2.bean生命周期. Spring对bean进行实例化. Spring将值和bean的引用注入到bean对应的属性中. 如果 bean 实现BeanNameAware接口,Spring将bean的ID传递给setBeanName()方法. 如果bean实现了BeanFactoryAware接口,Spring将调用setBeanFactory()方法,将BeanFactory容器实例传入. 如果bean实现了ApplicationContextAware接口,Spring将调用setApplicationContext()方法,将bean所在的应用上下文的引用传入进来. 如果bean实现了BeanPostProcessor接口,Spring将调用它们的postProcessBeforeInitialization()方法. 如果bean实现了InitializingBean接口,Spring将调用它们的afterPropertiesSet()接口方法.类似的,如果bean使用init-method声明了初始化方法,该方法也会被调用. 如果bean实现了BeanPostProcessor接口,Spring将调用它们的postProcessAfterInitialization()方法. 此时,bean将驻留在应用上下文中,直到应用上下文被销毁. 如果bean实现了了DisposableBean接口,Spring将调用它的Destroy()接口方法.如果bean使用destroy-method声明了销毁方法,该方法也会被调用. 三.Spring的模块划分. Data access &amp;integration Web and romoting AOP Instrumentation Core Spring container Test JDBC Web AOP Instrument Beans Test ORM Servlet Aspects Instrument Tomcat Core Transaction Portlet Context OXM Struts Expression JMS Contextsupport 四.总结.Spring是一个框架,这个框架的核心是容器,现在大部分使用的容器类型是应用上下文,Spring主要通过应用上下文去管理bean.]]></content>
      <categories>
        <category>Java读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识之Lambda表达式]]></title>
    <url>%2F2018%2F09%2F03%2FJava%E7%9F%A5%E8%AF%86%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文主要讲解Lambda表达式的相关知识 一.Lambda简介 面向对象编程思想做一件事，找一个能解决这个事情的的对象，调用该方法，完成这件事情，注重的是过程. 函数式编程思想做一件事，不在乎具体是谁做的，怎么做的，注重的是结果.Lambda表达式则是函数式编程思想，这是Java8出现的新特性，主要是为了简化代码. 二.Lambda表达式的格式Lambda格式由3个部分组成： 一些参数 一个箭头 一段代码Lambda表达式为： 123(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125; 注： 小括号内的语法与传统方法参数列表一致:无参数则留空,多个参数则用逗号分隔. ‐&gt; 是新引入的语法格式，代表指向动作,大括号内的语法与传统方法体要求基本一致. 1.Lambda格式(无参无返回值)123() ‐&gt; &#123; // 这里可以是一条打印语句&#125; 2.Lambda格式(有参有返回值)123(参数类型 参数名称) ‐&gt; &#123; return 返回值; &#125; 3.Lambda格式(省略)1() ‐&gt; // 这里可以是一条打印语句 注：省略了大括号 二.Lambda例子1.无参无返回值启用一个线程，采用匿名内部类的方式，一条打印输出的语句 12345678// 简化前的代码Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println("当前线程是：" + Thread.currentThread().getName()); &#125;&#125;;new Thread(r).start(); 以上线程重点在于打印输出的语句，所以可以简化代码为： 1234// 简化后的代码new Thread(() -&gt; &#123; System.out.println("当前线程是：" + Thread.currentThread().getName());&#125;).start(); 分析：简化后的代码中-&gt;左侧的()中的参数为简化前的代码中run()的参数，简化后的代码中-&gt;右侧的大括号对应简化前的代码中run()右侧的大括号，Lambda表达式在一定程度上使代码更精简，更美观注：例子1就是无参无返回值的例子 2.有参有返回值定义一个list数组，添加两个map 123456789101112List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;&gt;();Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();map1.put("name", "王可可");map1.put("age", "23");list.add(map1);Map&lt;String, String&gt; map2 = new HashMap&lt;&gt;();list.add(map2);map2.put("name", "李多多");map2.put("age", "18");System.out.println(list);// 结果：[&#123;name=王可可, age=23&#125;, &#123;name=李多多, age=18&#125;] 按照年龄从小到大排序 12345678// obj1:李多多 obj2:王可可list.sort((Map&lt;String, String&gt; obj1, Map&lt;String, String&gt; obj2) -&gt; &#123; // compareTo负数 obj1在前，obj2在后 int res = obj1.get("age").compareTo(obj2.get("age")); return res; &#125;);System.out.println(list);// 结果：[&#123;name=李多多, age=18&#125;, &#123;name=王可可, age=23&#125;] 3.省略格式继续引用第一个例子，还可以简化为以下格式 123new Thread(() -&gt; System.out.println("当前线程是：" + Thread.currentThread().getName())).start(); 注：唯一的区别是去掉了，大括号{}和大括号中打印语句后的封号；]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java知识之反射]]></title>
    <url>%2F2018%2F08%2F23%2FJava%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[本文主要讲解反射的相关知识 一.获取类对象 getClass()，class()，forName() 1.获取类对象可以使用以下三种方法 对象名调用getClass()方法 类名调用class()方法 Class调用forName()方法，参数是类所在的文件相对路径 例子：Peo类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class Peo &#123; private String name; private int age; public double heigth; private double weight; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getHeigth() &#123; return heigth; &#125; public void setHeigth(double heigth) &#123; this.heigth = heigth; &#125; public double getWeight() &#123; return weight; &#125; public void setWeight(double weight) &#123; this.weight = weight; &#125; public void run() &#123; System.out.println("peo is running"); &#125; private void run(String name) &#123; System.out.println(name + " is running"); &#125; void run(String name, String age) &#123; System.out.println(name + " is running , " + name + " is " + age); &#125; protected void run(String name, String age, double heigth) &#123; System.out.println(name + " is running , " + name + " is " + age + " , " + name + " is " + heigth); &#125; public void walk(String name) &#123; System.out.println("单参方法: " + name + " is walking"); &#125; public void jump() &#123; System.out.println("无参方法: " + "Peo is jumping"); &#125; // 无参构造方法 public Peo() &#123; &#125; // 单个参数构造方法，私有 private Peo(int age) &#123; this.age = age; &#125; // 单个参数构造方法，受保护的 protected Peo(String name) &#123; this.name = name; &#125; // 单个参数构造方法，默认不修饰 Peo(doubleweight) &#123; this.weight = weight; &#125; // 多参构造方法 public Peo(String name, int age, double heigth, double weight) &#123; this.name = name; this.age = age; this.heigth = heigth; this.weight = weight; &#125;&#125; 方法调用 1234567Peo peo = new Peo();// 对象名.getClassClass c1 = peo.getClass();// 类名.classClass c2 = Peo.class;// Class.forName("类所在的文件相对路径")Class c3 = Class.forName("com.Case.Peo"); 二.获取类的构造方法 getConstructors()、getDeclaredConstructors()、getConstructor()、getDeclaredConstructor() 1.获取类的多个构造方法 类对象调用getConstructors()方法 获取多个public修饰的构造方法 类对象调用getDeclaredConstructors()方法 获取多个public、protected、private、和default修饰的构造方法 123456789Class c2 = Peo.class;Constructor[] constructors = c2.getConstructors();for (int i = 0; i &lt; constructors.length; i++) &#123; System.out.println("constructors:" + constructors[i]);&#125;Constructor[] declaredConstructors= c2.getDeclaredConstructors();for (int i = 0; i &lt; declaredConstructors.length; i++) &#123; System.out.println("declaredConstructors:" + declaredConstructors[i]);&#125; 打印结果 12345678constructors:public com.Case.Peo()constructors:public com.Case.Peo(java.lang.String,int,int,int)--------------------------------------------------------------declaredConstructors:public com.Case.Peo()declaredConstructors:private com.Case.Peo(int)declaredConstructors:protected com.Case.Peo(java.lang.String)declaredConstructors:com.Case.Peo(java.lang.double)declaredConstructors:public com.Case.Peo(java.lang.String,int,double,double) 根据结果，getConstructors()方法，返回的是public修饰的构造方法，getDeclaredConstructors()返回的是public、protected、private、和default的构造方法 2.获取指定的无参构造方法 类对象调用getConstructor()方法 获取无参构造方法 1234Peo peo = new Peo();Class c1 = peo.getClass();Constructor constructor = c1.getConstructor();System.out.println("无参构造方法: " + constructor); 打印结果 1无参构造方法: public com.Case.Peo() 3.获取指定的有参构造方法 类对象调用getDeclaredConstructor(对应参数类型的类对象)方法 获取有参构造方法 1234Peo peo = new Peo();Class c1 = peo.getClass();Constructor constructorInt = c1.getDeclaredConstructor(int.class);System.out.println("有参构造方法: " + constructorInt); 打印结果 1有参构造方法: private com.Case.Peo(int) 注意：当构造方法是public修饰，使用getConstructor()或getDeclaredConstructor()都可以，其他修饰符，使用getDeclaredConstructor()获取构造方法，如果构造方法参数是int，方法中的参数为int.class，如果构造方法参数是String，方法中的参数为String.class，如果构造方法是public Peo(String name, int age, double heigth, double weight)，调用示例为：getDeclaredConstructor(“String.class, int.class, double.class, double.class“) 三.获取类的方法 getMethods()、getDeclaredMethods()、getMethod()、getDeclaredMethod() 1.获取类的多个方法 类对象调用getMethods()方法 获取多个public修饰的方法、继承类的public修饰的方法和该类所实现接口的方法 类对象调用getDeclaredMethods()方法 获取多个public、protect、private、default修饰的方法和该类所实现接口的方法 123456789Class c2 = Peo.class;Method[] methods = c2.getMethods();for (int i = 0; i &lt; methods.length; i++) &#123; System.out.println("methods:" + methods[i]);&#125;Constructor[] declaredMethods= c2.getDeclaredMethods();for (int i = 0; i &lt; declaredMethods.length; i++) &#123; System.out.println("declaredMethods:" + declaredMethods[i]);&#125; 打印结果 1234567891011121314151617181920212223242526272829303132methods:public void com.Case.Peo.run()methods:public java.lang.String com.Case.Peo.getName()methods:public void com.Case.Peo.setName(java.lang.String)methods:public void com.Case.Peo.setAge(int)methods:public double com.Case.Peo.getHeigth()methods:public double com.Case.Peo.getWeight()methods:public int com.Case.Peo.getAge()methods:public void com.Case.Peo.setWeight(double)methods:public void com.Case.Peo.setHeigth(double)methods:public void com.Case.Peo.walk(java.lang.String)methods:public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionmethods:public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionmethods:public final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionmethods:public boolean java.lang.Object.equals(java.lang.Object)methods:public java.lang.String java.lang.Object.toString()methods:public native int java.lang.Object.hashCode()methods:public final native java.lang.Class java.lang.Object.getClass()methods:public final native void java.lang.Object.notify()methods:public final native void java.lang.Object.notifyAll()-------------------------------------------------------------------------------------declaredMethods:private void com.Case.Peo.run(java.lang.String)declaredMethods:public void com.Case.Peo.run()declaredMethods:void com.Case.Peo.run(java.lang.String,java.lang.String)declaredMethods:protected void com.Case.Peo.run(java.lang.String,java.lang.String,double)declaredMethods:public java.lang.String com.Case.Peo.getName()declaredMethods:public void com.Case.Peo.setName(java.lang.String)declaredMethods:public void com.Case.Peo.setAge(int)declaredMethods:public double com.Case.Peo.getHeigth()declaredMethods:public double com.Case.Peo.getWeight()declaredMethods:public int com.Case.Peo.getAge()declaredMethods:public void com.Case.Peo.setWeight(double)declaredMethods:public void com.Case.Peo.setHeigth(double) 根据结果，Peo类继承Object， 所以getMethods()方法，返回的是public修饰的方法以及Object类中的方法， declaredMethods()返回的是public、private、protected和default修饰的方法以及该类所实现接口的方法，不返回继承类的方法. 2.获取指定的无参方法 类对象调用getMethod(“方法名”)方法 获取无参方法，双引号中为方法名 123456Peo peo = new Peo();Class c1 = peo.getClass();// 获取无参的jump方法Method methodJ = c1.getMethod("jump");// 调用jump方法methodJ.invoke(peo); 打印结果 1无参方法: Peo is jumping 3.获取指定的有参方法 类对象调用getMethod(“方法名”，对应参数类型的类对象)方法 获取有参方法，双引号中为方法名 123456Peo peo = new Peo();Class c1= peo.getClass();// 获取有参的walk方法Method methodW = c1.getMethod("walk", String.class);// 调用walk方法methodW.invoke(peo, "xile"); 打印结果 1有参方法: xile is walking 四.获取类的成员变量 getFields()、getDeclaredFields()、getField()、getDeclaredField() 1.获取类的多个成员变量 类对象调用getFields()方法 获取多个public修饰的成员变量 类对象调用getDeclaredFields()方法 获取多个public、protect、private、default修饰的成员变量 123456789Class c2 = Peo.class;Field[] fields = c1.getFields();for (int i = 0; i &lt; fields.length; i++) &#123; System.out.println("fields:" + fields[i]);&#125;Field[] declaredFields = c1.getDeclaredFields();for (int i = 0; i &lt; declaredFields.length; i++) &#123; System.out.println("declaredFields:" + declaredFields[i]);&#125; 打印结果 12345fields:public double com.Case.Peo.heigthdeclaredFields:private java.lang.String com.Case.Peo.namedeclaredFields:private int com.Case.Peo.agedeclaredFields:public double com.Case.Peo.heigthdeclaredFields:private double com.Case.Peo.weight 根据结果，getFields()方法，返回的是public修饰的成员变量， declaredFields()返回的是public、private、protected和default修饰的成员变量. 2.获取指定的成员变量 类对象调用getField(“成员变量名”)方法 获取指定的public修饰的成员变量 1234567891011Peo peo = new Peo();Class c1 = peo.getClass();// 获取成员变量heigthField heigth = c1.getField("heigth");// 获取Peo对象Peo heigthObj = (Peo) c1.newInstance();// 暴力反射heigth.setAccessible(true);// 设置成员变量的值heigth.set(heigthObj, 180);System.out.println("成员变量heigth: " + heigthObj.getHeigth()); 打印结果 1成员变量heigth: 180.0 3.获取指定的成员变量 类对象调用getDeclaredgetField(“成员变量名”)方法 获取指定的public、protect、private、default修饰的成员变量 1234567Peo peo = new Peo();Class c1 = peo.getClass();Field weight = c1.getDeclaredField("weight");Peo weightObj = (Peo) c1.newInstance();weight.setAccessible(true);weight.set(weightObj, 140);System.out.println("成员变量weight: " + weightObj.getWeight()); 打印结果 1成员变量weight: 140.0 注意：当成员变量是public修饰，使用getgetField()或getDeclaredgetField()都可以，其他修饰符，使用getDeclaredgetField()获成员变量]]></content>
      <categories>
        <category>Java知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发之AWS mysql下载和配置]]></title>
    <url>%2F2018%2F06%2F28%2FJava%E5%BC%80%E5%8F%91%E4%B9%8BAWS%20mysql%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了在AWS中mysql的下载以及相关的配置 一.通过yum下载mysql的相关文件.1.进入etc文件目录.1cd /etc 2.下载mysql.1sudo yum install mysql 显示以下信息,表示下载并安装成功. 123456Installed: mysql.noarch 0:5.5-1.6.amzn1 Dependency Installed: mysql-config.x86_64 0:5.5.59-1.20.amzn1 mysql55.x86_64 0:5.5.59-1.20.amzn1 mysql55-libs.x86_64 0:5.5.59-1.20.amzn1 Complete! 3.下载mysql-server.1sudo yum install mysql-server 显示以下信息,表示下载并安装成功. 12345678910111213Installed: mysql-server.noarch 0:5.5-1.6.amzn1 Dependency Installed: mysql55-server.x86_64 0:5.5.59-1.20.amzn1 perl-Compress-Raw-Bzip2.x86_64 0:2.061-3.11.amzn1 perl-Compress-Raw-Zlib.x86_64 1:2.061-4.1.amzn1 perl-DBD-MySQL55.x86_64 0:4.023-5.23.amzn1 perl-DBI.x86_64 0:1.627-4.8.amzn1 perl-Data-Dumper.x86_64 0:2.145-3.5.amzn1 perl-IO-Compress.noarch 0:2.061-2.12.amzn1 perl-Net-Daemon.noarch 0:0.48-5.5.amzn1 perl-PlRPC.noarch 0:0.2020-14.7.amzn1 Complete! 4.下载mysql-devel.1sudo yum install mysql-devel 显示以下信息,表示下载并安装成功. 12345678910111213141516Installed: mysql-devel.noarch 0:5.5-1.6.amzn1 Dependency Installed: keyutils-libs-devel.x86_64 0:1.5.8-3.12.amzn1 krb5-devel.x86_64 0:1.15.1-8.43.amzn1 libcom_err-devel.x86_64 0:1.42.12-4.40.amzn1 libkadm5.x86_64 0:1.15.1-8.43.amzn1 libselinux-devel.x86_64 0:2.1.10-3.22.amzn1 libsepol-devel.x86_64 0:2.1.7-3.12.amzn1 libverto-devel.x86_64 0:0.2.5-4.9.amzn1 mysql55-devel.x86_64 0:5.5.59-1.20.amzn1 openssl-devel.x86_64 1:1.0.2k-12.109.amzn1 zlib-devel.x86_64 0:1.2.8-7.18.amzn1 Dependency Updated: openssl.x86_64 1:1.0.2k-12.109.amzn1 Complete! 二.配置mysql.1.进入mysql文件夹1cd /var/lib/mysql 2.将/var/lib路径下的mysql文件用户组设为mysql.1sudo chgrp -R mysql /var/lib/mysql 3.修改文件权限为可读可写可运行.1sudo chmod -R 770 /var/lib/mysql 4.开启mysql服务1sudo service mysqld start 显示mysql数据库正在初始化,之后开启mysql服务成功. 12345Initializing MySQL database: Installing MySQL system tables............Starting mysqld: [ OK ] 5.设置mysql登录的账号和密码.1/usr/bin/mysqladmin -u root password root 以上第一个root为账号名,第二个root为密码 6.连接mysql1mysql -u root -p 会显示: 1Enter password: 输入刚刚设置的密码root.之后显示mysql欢迎提示和版本信息. 123Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 8Server version: 5.5.59 MySQL Community Server (GPL) 7.显示当前所有的数据库.1mysql&gt;show databases; 显示 12345678+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || test |+--------------------+ 8.使用mysql.1mysql&gt;use mysql 9.创建新账号和密码,授予远程登录的任意ip全部权限.1grant all PRIVILEGES on *.* to root@&apos;%&apos; identified by &apos;root&apos;; 解释:all PRIVILEGES指所有权限,也可以给予部分权限,如:select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file等.第一个root为新的账号名.第二个root为新账号密码.*.*所有数据库的所有表.%为所有ip,此处可指定单个ip.某个ip用户例子: 1grant select,insert,update,delete,create,drop on test_database.* to baby@123.123.123.123 identified by &apos;123456&apos;; 表示:授予ip为123.123.123.123的用户baby分配可对test_database数据库的所有表进行select,insert,update,delete,create,drop操作的权限,并设定口令为123. 三.连接mysql.Mac本可以通过MysqlWorkbench工具进行连接.输入账号root,密码root即可. CSDNJava开发之AWS mysql下载和配置]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Java开发 AWS mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发之AWS redis下载和配置]]></title>
    <url>%2F2018%2F05%2F22%2FJava%E5%BC%80%E5%8F%91%E4%B9%8BAWS%20redis%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了在AWS中redis的下载以及相关的配置 一.从官网下载redis.下载文件名为:redis-4.0.9.tar.gz 二.将下载的redis文件上传AWS.1.通过SCP上传redis-4.0.9.tar.gz文件1scp -i /Users/lby/key.pem -r /Users/lby/Desktop/AWS文件/redis-4.0.9.tar.gz ec2-user@123.123.123.1523:/data 以上命令表示:将redis-4.0.9.tar.gz文件上传至服务器/data文件夹下. 注意:scp的具体用法可以参考之AWS jdk下载和配置标题二中的讲解. 三.解压redis-4.0.9.tar.gz文件并修改文件名.解压文件命令如下: 1tar -zxvf redis-4.0.9.tar.gz 此时当前路径下的文件名为redis-4.0.9.如果需修改文件名,使用以下命令: 1mv redis-4.0.9 redis 命令含义为:mv 原文件名 修改后文件名 四.redis配置.1.进入redis文件中.1cd /data/redis 2.执行make命令.1make 如果出现以下错误: 12345678910111213make[3]: Entering directory `/data/installfiles/redis-4.0.9/deps/hiredis&apos;gcc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb net.cmake[3]: gcc: Command not foundmake[3]: *** [net.o] Error 127make[3]: Leaving directory `/data/installfiles/redis-4.0.9/deps/hiredis&apos;make[2]: *** [hiredis] Error 2make[2]: Leaving directory `/data/installfiles/redis-4.0.9/deps&apos;make[1]: [persist-settings] Error 2 (ignored) CC adlist.o/bin/sh: cc: command not foundmake[1]: *** [adlist.o] Error 127make[1]: Leaving directory `/data/installfiles/redis-4.0.9/src&apos;make: *** [test] Error 2 根据gcc: Command not found提示可知,缺少gcc,那就安装gcc.通过yum安装gcc的命令: 1sudo yum install gcc 执行成功后显示: 12345678910111213Installed: gcc.noarch 0:4.8.5-1.22.amzn1 Dependency Installed: cpp48.x86_64 0:4.8.5-28.142.amzn1 gcc48.x86_64 0:4.8.5-28.142.amzn1 glibc-devel.x86_64 0:2.17-222.173.amzn1 glibc-headers.x86_64 0:2.17-222.173.amzn1 kernel-headers.x86_64 0:4.14.33-51.37.amzn1 libgcc48.x86_64 0:4.8.5-28.142.amzn1 libgomp.x86_64 0:6.4.1-1.45.amzn1 libmpc.x86_64 0:1.0.1-3.3.amzn1 mpfr.x86_64 0:3.1.1-4.14.amzn1 Complete! 3.执行make test命令.1make test 如果出现以下错误: 123456789101112make[1]: Entering directory `/data/installfiles/redis-4.0.9/src&apos; CC Makefile.depmake[1]: Leaving directory `/data/installfiles/redis-4.0.9/src&apos;make[1]: Entering directory `/data/installfiles/redis-4.0.9/src&apos; CC adlist.oIn file included from adlist.c:34:0:zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory #include &lt;jemalloc/jemalloc.h&gt; ^compilation terminated.make[1]: *** [adlist.o] Error 1make[1]: Leaving directory `/data/installfiles/redis-4.0.9/src’ 根据zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory提示可使用以下命令解决: 1make MALLOC=libc 显示 1Hint: It&apos;s a good idea to run &apos;make test&apos; ;) 4.重新执行make test命令1make test 5.执行make install命令1make install 6.进入redis下的src文件.1cd src 7.开启redis服务1./redis-server 如果以下信息表示redis服务开启成功. 12345678910111213141516171819 _._ _.-``__ &apos;&apos;-._ _.-`` `. `_. &apos;&apos;-._ Redis 4.0.8 (00000000/0) 64 bit .-`` .-```. ```\/ _.,_ &apos;&apos;-._ ( &apos; , .-` | `, ) Running in standalone mode |`-._`-...-` __...-.``-._|&apos;` _.-&apos;| Port: 6379 | `-._ `._ / _.-&apos; | PID: 39798 `-._ `-._ `-./ _.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | [http://redis.io](http://redis.io) `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; |`-._`-._ `-.__.-&apos; _.-&apos;_.-&apos;| | `-._`-._ _.-&apos;_.-&apos; | `-._ `-._`-.__.-&apos;_.-&apos; _.-&apos; `-._ `-.__.-&apos; _.-&apos; `-._ _.-&apos; `-.__.-&apos; 39798:M 10 Apr 17:21:48.446 # Server initialized39798:M 10 Apr 17:21:48.447 * Ready to accept connections 8.查看redis是否开启1./redis-cli 显示: 1127.0.0.1:6379&gt; 输入 1ping 显示:pong,表示,redis服务可以使用.也可以输入keys *查看redis缓存中的所有key. 1keys * 五.redis自启动配置.1.进入redis文件1cd /data/redis 2.将redis.conf文件复制到etc文件目录下1cp redis.conf /etc 3.进入etc文件1cd /etc 此时,etc文件下已经有redis.conf文件. 4.修改redis.conf文件中的daemonize no参数为daemonize yes.1vim redis.conf 输入i进入编辑状态. 1i 找到daemonize no参数,改为daemonize yes.强制写入保存并退出 1:wq! 5.使配置生效.1redis-server /etc/redis.conf 最终显示: 1236691:C 23 May 06:59:02.250 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo6691:C 23 May 06:59:02.250 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=6691, just started6691:C 23 May 06:59:02.250 # Configuration loaded 总结:到此,AWS中的redis配置就告一段落. CSDNJava开发之AWS redis下载和配置]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Java开发 AWS redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发之AWS jdk下载和配置]]></title>
    <url>%2F2018%2F03%2F13%2FJava%E5%BC%80%E5%8F%91%E4%B9%8BAWS%20jdk%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了在AWS中jdk的下载以及相关的配置 一.从官网下载jdk1.根据jdk链接下载JDK.如下图: 2.下载rpm包 二.将下载的jdk文件上传到AWS上1.通过SCP上传jdk-10.0.1_linux-x64_bin.rpm文件1scp -i /Users/lby/key.pem -r /Users/lby/Desktop/AWS文件/jdk-10.0.1_linux-x64_bin.rpm ec2-user@123.123.123.123:/data 说明:我们是通过私钥来访问AWS,私钥是.pem后缀的文件. -i 指identity_file,表示从指定文件中读取传输时使用的密钥文件,此参数直接传递给ssh. /Users/lby/key.pem为私钥文件的路径 -r 代表上传指定文件目录下的所有文件或指定的单个文件,传单个文件可以不带-r命令 /Users/lby/Desktop/AWS文件/jdk-10.0.1_linux-x64_bin.rpm为下载的jdk放置在本地的文件路径 ec2-user@123.123.123.123:指需要连接AWS的用户@ip: /data指服务器的data文件夹路径,这里的/data可以自定义.如:/data/kit/java 上传文件过程中可能出现问题:1Permission denied (publickey). 解决:私钥路径有可能不正确,scp后跟的是私钥文件路径,不是私钥文件名本身.上传的应是:/Users/lby/key.pem而不是key.pem. 以下正确 1scp -i /Users/lby/key.pem -r /Users/lby/Desktop/AWS文件/jdk-10.0.1_linux-x64_bin.rpm ec2-user@123.123.123.123:/data 以下错误 1scp -i key.pem -r /Users/lby/Desktop/AWS文件/jdk-10.0.1_linux-x64_bin.rpm ec2-user@123.123.123.123:/data 如果私钥路径上传正确,那么有可能问题是服务器的文件夹权限太低.即服务器的data文件权限太低.用以下命令修改文件权限: 1chmod 750 /data 如果出现:chmod: changing permissions of ‘/data’: Operation not permitted则使用: 1sudo chmod 750 /data 三.卸载服务器上自带的openJDK,通过rpm安装jdk1.查看openJDK1rpm -qa|grep java 显示以下两个包 java-1.8.0-openjdk-1.8.0.0-1.45.1.11.1.el8.x86_64tzdata-java-2018c-1.el8.noarch 2.删除openJDK相关的包分别执行以下两条命令 12rpm -e —nodeps java-1.8.0-openjdk-1.8.0.0-1.45.1.11.1.el8.x86_64rpm -e —nodeps tzdata-java-2018c-1.el8.noarch 3.给予jdk文件响应的权限1chmod 755 jdk-10.0.1_linux-x64_bin.rpm 4.通过rpm安装jdk1rpm -ivh jdk-10.0.1_linux-x64_bin.rpm 说明:-e : 删除这个包-ivh: -i 指要安装这个包,-v指输出信息增加,-h指安装过程中显示hashes作为在安装过程的一个进度条. 四.环境变量配置jdk8以及8之前的版本中都有tool.jar和dt.jar两个jar包,而jdk9以上版本都取消了这两个包,做了内部集成,所以,环境变量也不需要再配置了,节省配置JAVA_HOME和PATH的时间.现在,在服务器上输入 1java --version 是否出现 123java 10.0.1 2018-04-17Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, mixed mode) 五.总结AWS中jdk部分的配置就告一段落了,不知道你有没有配置成功呢~~~ CSDNJava开发之AWS jdk下载和配置]]></content>
      <categories>
        <category>Java开发</category>
      </categories>
      <tags>
        <tag>Java开发 AWS jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之常用分类]]></title>
    <url>%2F2017%2F09%2F30%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[本文介绍了常用的一些分类. 一.UIColor分类(十六进制转颜色)123456789101112131415161718/** 十六进制转颜色 @param hexStr 十六进制字符串 @return 颜色对象 */+ (instancetype)colorWithHexStr:(NSString *)hexStr&#123; if ([hexStr hasPrefix:@"#"]) &#123; hexStr = [hexStr stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:@""]; &#125; NSInteger redColorNum = strtoul([[hexStr substringWithRange:NSMakeRange(0, 2)] UTF8String],0,16); NSInteger greenColorNum = strtoul([[hexStr substringWithRange:NSMakeRange(2, 2)] UTF8String],0,16); NSInteger blueColorNum = strtoul([[hexStr substringWithRange:NSMakeRange(4, 2)] UTF8String],0,16); UIColor *color = BYColor(redColorNum, greenColorNum, blueColorNum); return color;&#125; 二.UITextField分类(手机账号和密码验证)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485- (BOOL)isEmptyText&#123; return self.text.length == 0;&#125;/* 中国移动: 135、136、137、138、139、147（数据卡）、148、150、151、152、157、158、159、178、182、183、184、187、188、198、 134（0-8）、1440、1703、1705、1706 中国联通: 130、131、132、145（数据卡）、146、155、156、166、175、176、185、186、 1707、1708、1709 、 中国电信: 133、149、153、173、177、180、181、189、199、 1349、1410、1700、1701、1702、 虛拟运营商: 1700、1705、1707、1708、1709......代理联通移动电信业务 */// 判断手机号码格式是否正确- (BOOL)isValidPhoneNumber&#123; // phoneNumber = [phoneNumber stringByReplacingOccurrencesOfString:@" " withString:@""]; if (self.text.length != 11) &#123; return NO; &#125; else &#123; /** * 移动号段正则表达式 * CM China Mobile */ NSString *CMPhoneSegmentRegExp = @"^1((3[5-9])|(4[7-8])|(5[0-2,7-9])|(78)|(8[2-4,7-8])|(98))\\d&#123;8&#125;|((34[0-8])|(440)|(70[3,5-6]))\\d&#123;7&#125;$"; /** * 联通号段正则表达式 * CU China Unicom */ NSString *CUPhoneSegmentRegExp = @"^1((13[0-2])|(4[5-6])|(5[5-6])|(66])|(7[5-6])|(8[5,6]))\\d&#123;8&#125;|(70[7-9])\\d&#123;7&#125;$"; /** * 电信号段正则表达式 * CT China Telecom */ NSString *CTPhoneSegmentRegExp = @"^1((33)|(49)|(53)|(17[3-7])|(18[0,1,9])|(99))\\d&#123;8&#125;((349)|(410)|(70[0-2]))\\d&#123;7&#125;$"; NSPredicate *predicateCM = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CMPhoneSegmentRegExp]; BOOL isMatchCM = [predicateCM evaluateWithObject:self.text]; NSPredicate *predicateCU = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CUPhoneSegmentRegExp]; BOOL isMatchCU = [predicateCU evaluateWithObject:self.text]; NSPredicate *predicateCT = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", CTPhoneSegmentRegExp]; BOOL isMatchCT = [predicateCT evaluateWithObject:self.text]; if (isMatchCM || isMatchCU || isMatchCT) &#123; return YES; &#125; else &#123; return NO; &#125; &#125;&#125;// 判断秘密格式为 6 - 18 位数字和字母组成- (BOOL)isValidPassword&#123; NSString *regExp = @"^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;6,18&#125;$"; NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", regExp]; if ([predicate evaluateWithObject:self.text]) &#123; return YES ; &#125; else &#123; return NO; &#125;&#125;// 长度是否超过6位数并小于18位数- (BOOL)isMoreThanSixLength&#123; return (self.text.length &gt;= 6 &amp;&amp; self.text.length &lt;= 18);&#125; 三.NSString分类(缓存路径)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取Documents目录+ (NSString *)documentPath&#123; return [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];&#125;// 获取Cache目录+ (NSString *)cachePath&#123; return [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];&#125;// 获取Tmp目录 + (NSString *)tempPath&#123; return NSTemporaryDirectory();&#125;// 获取拼接后的Documents目录- (NSString *)appendDocumentsPath&#123; NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString *fileName = [self lastPathComponent]; NSString *filePath = [documentsPath stringByAppendingPathComponent:fileName]; return filePath;&#125;// 获取拼接后的Cache目录- (NSString *)appendCachePath&#123; NSString *cachePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSString *fileName = [self lastPathComponent]; NSString *filePath = [cachePath stringByAppendingPathComponent:fileName]; return filePath;&#125;// 获取拼接后的Tmp目录- (NSString *)appendTmpPath&#123; NSString *tmpPath = NSTemporaryDirectory(); NSString *fileName = [self lastPathComponent]; NSString *filePath = [tmpPath stringByAppendingPathComponent:fileName]; return filePath;&#125; 后续再更…]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之cocoapods安装和使用]]></title>
    <url>%2F2017%2F08%2F26%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8Bcocoapods%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了cocoapods的安装和使用过程. 一.配置cocoapods1.删除源(这个系统自带的不好用) $ sudo gem sources -r https://rubygems.org/ 2.添加源(使用淘宝的镜像,记住要用https)(淘宝的镜像不更新了,建议以后使用https://gems.ruby-china.org/记录于2017.5.4) $ sudo gem sources -a https://ruby.taobao.org/ 3.查看是否使用的是淘宝镜像 $ gem sources -l 4.安装 cocoapods $ sudo gem install cocoapods 注意:在执行sudo gem install cocoapods命令时,出现错误:Error installing cocoapods:activesupport requires Ruby version &gt;= 2.2.0,表示要安装ruby大于等于2.2.0的版本(这里安装ruby2.3.0的版本). 5.查看ruby当前版本 $ ruby -v (当前版本是2.0.0) 注意:先安装rvm,通过rvm去安装2.3.0的ruby. 6.安装 rvmrvm:ruby Version Manager,ruby版本管理器,包括ruby的版本管理和Gem库管理(gemset) $ curl -L get.rvm.io | bash -s stable (等待一段时间后便成功安装 rvm) 7.查询rvm的当前版本 $ rvm -v 8.安装ruby 2.3.0 $ rvm install 2.3.0 9.再次查看ruby当前版本 $ ruby -v (版本为2.3.0) 10.再次安装cocoapods $ sudo gem install cocoapods 注意:出现Setting up CocoaPods master repo,说明Cocoapods在将它的信息下载到~/.cocoapods路径中;cd 到该目录中,用du -sh *命令来查看文件大小,每隔几分钟查看一次,这个目录最终大小是700多M,就表示下载完成了. 11.进入~/.cocoapods文件目录中 $ cd ~/.cocoapods 12.查看文件大小 $ du -sh * 13.安装成功之后,查看是否是最新版本(目前最新版本是1.0.1) $ pod –version 二.将第三方框架集成到项目中1.进入项目文件的目录中(BYSliderChooseView是项目文件名) $ cd /Users/lby/Desktop/GitHub/BYSliderChooseView 2.初始化一个podfile文件(在对应路径中创建podfile文件) $ pod init 3.搜索你需要用到的第三方框架(如:SDWebImage)找到之后,复制 pod ‘SDWebImage’ 到podfile中,如果要指定版本号,就跟上版本号就行. $ pod search SDWebImage(或$ pod ‘SDWebImage’, ‘~&gt; 4.1.0’) podfile文件中代码如下:(platform指支持的最低版本,可以根据项目情况调整,BYSliderChooseView是项目名称) platform :ios, ‘9.0’target ‘BYSliderChooseView’ dopod ‘SDWebImage’, ‘~&gt; 4.1.0’end 4.安装$ pod install (如果是更新使用:pod update –repo-no-update)完成之后有个提示:Please close any current Xcode sessions and use &#39;BYSliderChooseView.xcworkspace&#39; for this project from now on. 以上是之前安装和使用的过程,而这次做了一个尝试.(2017MacPro Without TouchBar)1.ruby版本不变,仍旧是2.0.0版本.2.使用系统自带的源.3.已经翻墙.所以,在什么都不改变的情况下,直接执行sudo gem install cocoapods命令,没有报错,有一系列执行结果,运行完成,再执行pod setup,出现Setting up CocoaPods master repo,等待,如果看到`Setup completed,就安装完成了. 附上操作内容:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136Last login: Thu Aug 24 12:52:58 on ttys000localhost:~ lby$ ruby -v(执行代码)ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin16]localhost:~ lby$ sudo gem install cocoapods(执行代码)Password:(执行代码)Fetching: i18n-0.8.6.gem (100%)Successfully installed i18n-0.8.6Fetching: thread_safe-0.3.6.gem (100%)Successfully installed thread_safe-0.3.6Fetching: tzinfo-1.2.3.gem (100%)Successfully installed tzinfo-1.2.3Fetching: minitest-5.10.3.gem (100%)Successfully installed minitest-5.10.3Fetching: activesupport-4.2.9.gem (100%)Successfully installed activesupport-4.2.9Fetching: nap-1.1.0.gem (100%)Successfully installed nap-1.1.0Fetching: fuzzy_match-2.0.4.gem (100%)Successfully installed fuzzy_match-2.0.4Fetching: cocoapods-core-1.3.1.gem (100%)Successfully installed cocoapods-core-1.3.1Fetching: claide-1.0.2.gem (100%)Successfully installed claide-1.0.2Fetching: cocoapods-deintegrate-1.0.1.gem (100%)Successfully installed cocoapods-deintegrate-1.0.1Fetching: cocoapods-downloader-1.1.3.gem (100%)Successfully installed cocoapods-downloader-1.1.3Fetching: cocoapods-plugins-1.0.0.gem (100%)Successfully installed cocoapods-plugins-1.0.0Fetching: cocoapods-search-1.0.0.gem (100%)Successfully installed cocoapods-search-1.0.0Fetching: cocoapods-stats-1.0.0.gem (100%)Successfully installed cocoapods-stats-1.0.0Fetching: netrc-0.7.8.gem (100%)Successfully installed netrc-0.7.8Fetching: cocoapods-trunk-1.2.0.gem (100%)Successfully installed cocoapods-trunk-1.2.0Fetching: cocoapods-try-1.1.0.gem (100%)Successfully installed cocoapods-try-1.1.0Fetching: molinillo-0.5.7.gem (100%)Successfully installed molinillo-0.5.7Fetching: CFPropertyList-2.3.5.gem (100%)Successfully installed CFPropertyList-2.3.5Fetching: colored2-3.1.2.gem (100%)Successfully installed colored2-3.1.2Fetching: nanaimo-0.2.3.gem (100%)Successfully installed nanaimo-0.2.3Fetching: xcodeproj-1.5.1.gem (100%)Successfully installed xcodeproj-1.5.1Fetching: escape-0.0.4.gem (100%)Successfully installed escape-0.0.4Fetching: fourflusher-2.0.1.gem (100%)Successfully installed fourflusher-2.0.1Fetching: gh_inspector-1.0.3.gem (100%)Successfully installed gh_inspector-1.0.3Fetching: ruby-macho-1.1.0.gem (100%)Successfully installed ruby-macho-1.1.0Fetching: cocoapods-1.3.1.gem (100%)Successfully installed cocoapods-1.3.1Parsing documentation for i18n-0.8.6Installing ri documentation for i18n-0.8.6Parsing documentation for thread_safe-0.3.6Installing ri documentation for thread_safe-0.3.6Parsing documentation for tzinfo-1.2.3Installing ri documentation for tzinfo-1.2.3Parsing documentation for minitest-5.10.3Installing ri documentation for minitest-5.10.3Parsing documentation for activesupport-4.2.9unable to convert "\x84" from ASCII-8BIT to UTF-8 for lib/active_support/values/unicode_tables.dat, skippingInstalling ri documentation for activesupport-4.2.9Parsing documentation for nap-1.1.0Installing ri documentation for nap-1.1.0Parsing documentation for fuzzy_match-2.0.4Installing ri documentation for fuzzy_match-2.0.4Parsing documentation for cocoapods-core-1.3.1Installing ri documentation for cocoapods-core-1.3.1Parsing documentation for claide-1.0.2Installing ri documentation for claide-1.0.2Parsing documentation for cocoapods-deintegrate-1.0.1Installing ri documentation for cocoapods-deintegrate-1.0.1Parsing documentation for cocoapods-downloader-1.1.3Installing ri documentation for cocoapods-downloader-1.1.3Parsing documentation for cocoapods-plugins-1.0.0Installing ri documentation for cocoapods-plugins-1.0.0Parsing documentation for cocoapods-search-1.0.0Installing ri documentation for cocoapods-search-1.0.0Parsing documentation for cocoapods-stats-1.0.0Installing ri documentation for cocoapods-stats-1.0.0Parsing documentation for netrc-0.7.8Installing ri documentation for netrc-0.7.8Parsing documentation for cocoapods-trunk-1.2.0Installing ri documentation for cocoapods-trunk-1.2.0Parsing documentation for cocoapods-try-1.1.0Installing ri documentation for cocoapods-try-1.1.0Parsing documentation for molinillo-0.5.7Installing ri documentation for molinillo-0.5.7Parsing documentation for CFPropertyList-2.3.5Installing ri documentation for CFPropertyList-2.3.5Parsing documentation for colored2-3.1.2Installing ri documentation for colored2-3.1.2Parsing documentation for nanaimo-0.2.3Installing ri documentation for nanaimo-0.2.3Parsing documentation for xcodeproj-1.5.1Installing ri documentation for xcodeproj-1.5.1Parsing documentation for escape-0.0.4Installing ri documentation for escape-0.0.4Parsing documentation for fourflusher-2.0.1Installing ri documentation for fourflusher-2.0.1Parsing documentation for gh_inspector-1.0.3Installing ri documentation for gh_inspector-1.0.3Parsing documentation for ruby-macho-1.1.0Installing ri documentation for ruby-macho-1.1.0Parsing documentation for cocoapods-1.3.1Installing ri documentation for cocoapods-1.3.127 gems installedlocalhost:~ lby$ cd ~/.cocoapods(执行代码)-bash: cd: /Users/lby/.cocoapods: No such file or directorylocalhost:~ lby$ gem sources -l(执行代码)*** CURRENT SOURCES ***[https://rubygems.org/](https://rubygems.org/)localhost:~ lby$ pod setup(执行代码)Setting up CocoaPods master repo $ /usr/bin/git clone [https://github.com/CocoaPods/Specs.git](https://github.com/CocoaPods/Specs.git) master --progress Cloning into 'master'... remote: Counting objects: 1483411, done. remote: Compressing objects: 100% (316/316), done. remote: Total 1483411 (delta 169), reused 230 (delta 96), pack-reused 1482979 Receiving objects: 100% (1483411/1483411), 419.73 MiB | 1.35 MiB/s, done. Resolving deltas: 100% (768999/768999), done. Checking out files: 100% (176707/176707), done.Setup completedlocalhost:~ lby$ cd ~/.cocoapods(执行代码)localhost:.cocoapods lby$ ls(执行代码)reposlocalhost:.cocoapods lby$ 简书iOS开发之cocoapods安装和使用]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS读书笔记之Effective Objective-C 2.0]]></title>
    <url>%2F2017%2F07%2F24%2FiOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BEffective%20Objective-C%202.0%2F</url>
    <content type="text"><![CDATA[本文主要对书中每个章节的要点进行梳理. 第1章.熟悉Objective - C第1条.了解Objective-C语言的起源 要点 Objective-C为C语言添加了面向对象特性，是其超集。Objective-C使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行环境而非编译器来决定。理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。 第2条.在类的头文件中尽量少引入其他头文件 要点 除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至&quot;class-continuation分类&quot;中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 第3条.多用字面量语法少用与之等价的方法 要点 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。应该通过取下标操作来访问数组下标或字典中的键所对应的元素。用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。 第4条.多用类型常量少用define预处理器指令 要点 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。在实现文件中使用static const来定义”只在编译单元内可见的常量”(translation-unit-specific constant)。由于此类常量不在全局符号表中，所以无需为其名称加前缀。在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称要加以区隔，通常用与之相关的类名做前缀。 第5条.用枚举表示状态、选项、状态码 要点 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。如果把传递给某个方法的选项表示为枚举型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有的枚举。 第2章.对象、消息、运行期(runtime)第6条.理解“属性”这一概念 要点 可以通过@property语法来定义对象中所封装的数据。通过&quot;特质&quot;来指定存储数据所需的正确语义。在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。开发iOS程序时，应该使用nonatomic属性，因为atomic属性会严重影响性能。 第7条.在对象内部尽量直接访问实例变量 要点 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，应该通过属性来写。在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据。有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。 第8条.理解“对象等同性”这一概念 要点 若想检测对象的等同性，请提供“isEqual:”与hash方法。相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。不要盲目的逐个监测每条属性，而是应该依照具体需求来制定检测方案。编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。 第9条.以“类族模式”隐藏实现细节 要点 类族模式可以把实现细节隐藏在一套简单的公共接口后面。系统框架中经常使用类族。从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。 第10条.在既有类中，使用关联对象(Associated Object)存放自定义数据 要点 可以通过“关联对象”机制来把两个对象连起来。定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。 第11条.理解objc_msgSend的作用 要点 消息由接收者，选择子(selector)及参数构成。给某对象“发送消息”(invoke a message)也就相当于在该对象上&quot;调用方法&quot;(call a method)。发给某对象的全部消息都要由“动态消息派发系统”来处理，该系统会查出对应的方法，并执行其代码。 第12条.理解消息转发机制 要点 若对象无法响应某个选择子(selector)，则进入消息转发流程。通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。对象可以将其无法解读的某些选择子(selector)转交给其他对象处理。经过上述两步后，如果还是没办法处理选择子(selector)，那就启动完整的消息转发机制。 第13条.用”方法调配技术”(method swizzling)调试黑盒方法 要点 在运行期(runtime)中，可以向类中新增或替换选择子(selector)所对应的方法实现。使用另一份实现来替换原有的方法实现，这道工序叫做&quot;方法调配&quot;(method swizzling)，开发者常用此技术向原有实现中添加功能。一般来说，只有调试程序的时候才需要在runtime中修改方法实现，这种做法不宜滥用。 第14条.理解“类对象”的用意 要点 每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。 第3章.接口与API设计第15条.用前缀避免命名空间冲突 要点 选择与你公司、应用程序或者二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。 第16条.提供“全能初始化方法” 要点 在类中提供一个全能初始化方法，并于文档里指明。其它初始化方法均应调用此方法。若全能初始化方法与超类不同，则需覆写超类中的对应方法。如果超类的初始化方法并不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。 第17条.实现description方法 要点 实现description方法返回一个有意义的字符串，用以描述该实例。若想在调试时打印出更详尽的对象描述信息，则应实现debugDescription方法。 第18条.尽量使用不可变对象 要点 尽量创建不可变的对象。若某属性仅可于对象内部修改，则在“class-continuation分类”中将其由readonly属性扩展为readwrite属性。不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。 第19条.使用清晰而协调的命名方式 要点 起名时应遵从标准的Objective-C命名规范，这样创建出来的接口更容易为开发者所理解。方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。方法名里不要使用缩略后的类型名称。给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。 第20条.为私有方法名加前缀 要点 给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开。不要单用一个下划线做私有方法的前缀，因为这种做法的预留给苹果公司用的。 第21条.理解Objective-C错误模型 要点 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。在错误不那么严重的情况下，可以指派&quot;委托方法&quot;(delegate method)来处理错误，也可把错误信息放在NSError对象里，经由&quot;输出参数&quot;返回给调用者。 第22条.理解NSCopying协议 要点 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。 第4章.协议与分类第23条.通过委托与数据源协议进行对象间通信 要点 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。当某对象需要从另外一个对象中获取数据时，可使用委托模式。在这种情况下，该模式亦称&quot;数据源协议&quot;(data source protocal)。若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。 第24条.将类的实现代码分散到便于管理的数个分类之中 要点 使用分类机制把类的实现代码划分成易于管理的小块。将应该视为私有的方法归入名叫Private的分类中，以隐藏实现细节。 第25条.总是为第三方类的分类名称加前缀 要点 向第三方类中添加分类时，总应给其名称加上你专用的前缀。向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。 第26条.勿在分类中声明属性 要点 把封装数据所用的全部属性都定义在主接口里。在&quot;class-continuation&quot;分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性。 第27条.使用”class-continuation分类”隐藏实现细节 要点 通过&quot;class-continuation分类&quot;向类中新增实例变量。如果某属性在主接口中声明为&quot;只读&quot;，而类的内部又要用设置方法修改此属性，那么就在&quot;class-continuation分类&quot;中将其扩展为&quot;可读写&quot;。把私有方法的原型声明在&quot;class-continuation分类&quot;里面。若想使类遵循的协议不为人所知，则可于class-continuation分类中声明。 第28条.通过协议提供匿名对象 要点 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法。使用匿名对象来隐藏类型名称或类名。如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。 第5章.内存管理第29条.理解引用计数 要点 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1.若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。在对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 第30条.以ARC简化引用计数 要点 在ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可省去类中的许多”样板代码”。ARC管理对象生命期的办法基本上就是：在合适的地方插入&quot;保留&quot;及&quot;释放&quot;操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明, 而原来则需要手工执行”保留”及”释放”操作。由方法所返回的对象,其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则。ARC只负责管理Objective-C对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。 第31条.在dealloc方法中只释放引用并解除监听 要点 在dealloc方法里，应该做的事情就是释放指向其它对象的引用，并取消原来订阅的&quot;键值观测&quot;(KVO)或NSNotificationCenter等通知，不要做其他事情。如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定 : 用完资源后必须调用close方法。执行异步任务的方法不应在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。 第32条.编写”异常安全代码”时留意内存管理问题 要点 捕获异常时，一定要注意将try块内所创立的对象清理干净。在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 第33条.以弱引用避免保留环(循环引用) 要点 将某些引用设为weak，可避免出现&quot;保留环&quot;(循环引用)。weak引用可以自动清空，也可以不自动清空。自动清空(autoniling)是随着ARC而引入的新特性，由运行期系统(runtime)来实现，在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。 第34条.以”自动释放池块”降低内存峰值 要点 自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。合理运用自动释放池，可降低应用程序的内存峰值。@autoreleasepool这种新式写法能创建出更为轻便的自动释放池。 第35条.用“僵尸对象”调试内存管理问题 要点 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled可开启此功能。系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子(selector),响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。 第36条.不要使用retainCount 要点 对象的保留计数看似有用，实则不然，因为任何给定时间点上的&quot;绝对保留计数&quot;(absolute retainCount)都无法反映对象生命期的全貌。引入ARC后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。 第6章.块(block)与大中枢派发(GCD)第37条.理解”块”(block)这一概念 要点 block是C、C++、Objective-C中的词法闭包。block可接收参数，也可返回值。block可以分配在栈或堆上，也可以是全局的。分配在栈上的block可拷贝到堆里，这样的话，就和标准的Objective-C对象一样，具备引用计数了。 第38条.为常用的block类型创建typedef 要点 以typedef重新定义block类型，可以令block变量用起来更加简单。定义新类型时应遵循现有的命名习惯，勿使其名称与别的的类型相冲突。不妨为同一个block签名定义多个类型别名。如果要重构的代码使用了block类型的某个别名，那么只需修改相应的typedef中的block签名即可，无需改动其他typedef。 第39条.用handler块降低代码分散程度 要点 在创建对象时，使用内联的handler块将相关业务逻辑一并声明。在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用handler块来实现，则可直接将块(block)与相关对象放在一起。设计API时如果用到了handler块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块(block)安排在哪个队列上执行。 第40条.用block引用其所属对象时不要出现循环引用 要点 如果block所捕获的对象直接或间接的保留了块(block)本身，那么就得当心循环引用的问题。一定要找个适当的时机解除保留环(循环引用)，而不能把责任推给API的调用者。 第41条.多用派发队列，少用同步锁 要点 派发队列可用来表述同步语义(synchronous semantic)，这种做法要比使用@synchronized块或NSLock对象更简单。将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。使用同步队列及栅栏块，可以领同步行为更加高效。 第42条.多用GCD，少用performSelector系列方法 要点 performSelector系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子(selector)具体是什么，因而ARC编译器就无法插入适当的内存管理方法。performSelector系列方法所能处理的选择子(selector)太过局限了，选择子(selector)的返回值类型及发送给方法的参数个数都受到限制。如果想把任务放在另一个线程上执行，那么最好不要用performSelector系列方法而是应该把任务封装到块(block)里然后调用大中枢派发(GCD)机制的相关方法来实现。 第43条.掌握GCD及操作队列的使用时机 要点 在解决多线程与任务管理问题时，派发队列并非唯一方案。操作队列提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。 第44条.通过Dispatch Group机制,根据系统资源状况来执行任务 要点 一系列任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。 第45条.使用dispatch_once来执行只需运行一次的线程安全代码 要点 经常需要编写&quot;只需执行一次的线程安全代码&quot;(thread-safe single-code execution)。通过GCD所提供的dispatch_once函数，很容易就能实现此功能。标记应该声明在static或global作用域中，这样的话，在把只需执行一次的块(block)传给dispatch_once函数时，传进去的标记也是相同的。 第46条.不要使用dispatch_get_current_queue 要点 dispatch_get_current_queue函数的行为常常与开发者所预期的不同。此函数已废弃，只应做调试之用。由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述&quot;当前队列&quot;这一概念。dispatch_get_current_queue函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。 第7章.系统框架第47条.熟悉系统框架 要点 许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。很多常见任务都能用框架来做，例如音频与视频处理、网络通信数据管理等。请记住：用纯C写成的框架与用Objective-C写成的一样重要，若想成为优秀的Objective-C开发者，应该掌握C语言的核心概念。 第48条.多用块枚举，少用for循环 要点 遍历collection有4种方式。最基本的办法是for循环，其次是NSEnumerator遍历方法及快速遍历方法，最新、最先进的方式则是&quot;块枚举法&quot;。&quot;块枚举法&quot;本身就能通过GCD来并发执行遍历操作，无需另行编写代码。而采用其他遍历方式则无法轻易实现这一点。若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。 第49条.对自定义其内存管理语义的collection使用无缝桥接 要点 通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之前来回转换。在CoreFoundation层面创建collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内存管理语义的Objective-C collection。 第50条.构建缓存是选用NSCachae而非NSDictionary 要点 实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是&quot;线程安全的&quot;，此外，它与字典不同，并不会拷贝键。可以给NSCache对象设置上限，用以限制缓存中的对象总个数及&quot;总成本&quot;，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的”硬限制”(hard limit)，他们仅对NSCache起指导作用。将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占内存为系统丢弃时，该对象自身也会从缓存中移除.如果缓存使用得当。那么应用程序的响应速度就能提高。只有那种”重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。 第51条.精简initialize与load的实现代码 要点 在加载阶段，如果实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。首次使用某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的复写规则，所以通常应该在里面判断当前要初始化的是哪个类。load与initialize方法都应该实现的精简一些，这有助于保持应用程序的响应能力，也能减少引入&quot;依赖环&quot;(interdependency cycle)的几率。无法在编译期设定的全局常量，可以放在initialize方法里初始化。 第52条.别忘了NSTimer会保留其目标对象 要点 NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。反复执行任务的计时器(repeating timer)，很容易引入保留环(循环引用)，进入过这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环(循环引用)。这种保留环关系(循环引用)，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。可以扩充NSTimer的功能，用”块”来打破保留环(循环引用)。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。 以上内容为书中的重点部分,优先整理,后续陆续整理对每个章节的具体讲解.希望能帮助到你. 简书iOS读书笔记之Effective Objective-C 2.0]]></content>
      <categories>
        <category>iOS读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>52个有效方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS读书笔记之Objective-C高级编程(GCD)]]></title>
    <url>%2F2017%2F07%2F02%2FiOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8BObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B(GCD)%2F</url>
    <content type="text"><![CDATA[本文主要对GCD的概念、API以及实现进行梳理. GCD的概念.GCD,全称是Grand Central Dispatch,它是C语言的API.GCD的核心 : 将block(任务)添加到queue(队列)中. 根据官方文档ConcurrencyProgramingGuide中的描述: One of the technologies for starting tasks asynchronously is Grand Central Dispatch (GCD). This technology takes the thread management code you would normally write in your own applications and moves that code down to the system level. All you have to do is define the tasks you want to execute and add them to an appropriate dispatch queue. GCD takes care of creating the needed threads and of scheduling your tasks to run on those threads. Because the thread management is now part of the system, GCD provides a holistic approach to task management and execution, providing better efficiency than traditional threads. 翻译如下: Grand Central Dispatch(GCD)是异步执行任务的技术之一.一般将应用程序中记述的线程管理用的代码在系统级中实现.开发者只需定义想执行的任务并追加到适当的Dispatch Queue中,GCD就能生成必要的线程并执行任务,这样就比以前的线程更有效率. GCD使用步骤 创建任务 : 确定具体要做的事. GCD中的任务是使用block封装的. 将任务添加到队列中 GCD会自动将队列中的任务取出,放到对应的线程中执行. 任务的取出遵循队列的FIFO原则 : 先进先出,后进后出. 日常使用123456789101112131415161718192021dispatch_queue_t queue = dispatch_get_global_queue(0, 0);/** * 长时间处理 * * 例如 AR 用画像识别 * 例如数据库访问 */dispatch_async(queue, ^&#123; /** * 长时间处理结束,主线程使用该处理结果 */ dispatch_async(dispatch_get_main_queue(), ^&#123; /** * 只有在主线程可以执行的处理 * * 例如用户界面更新 */ &#125;);&#125;); 在GCD之前,Cocoa框架提供了NSObject类的performSelectorInBackground:withObject:实例方法和performSelectorOnMainThread:withObject:waitUntilDone:实例方法等简单的多线程编程技术.以下方法等价于GCD的实现:12345678910111213141516171819202122232425262728293031323334353637383940/** * NSObject performSelectorInBackground: withObject:方法中 * 执行后台线程 */- (void)launchThreadByNSObject_performSelectorInBackground_withObject&#123; [self performSelectorInBackground:@selector(doWork) withObject:nil];&#125;- (void)doWork&#123; /** * 因为书本是基于MRC环境所写,所以包含自动释放池,若在ARC环境下,以下语句会报错. */ NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; /** * 长时间处理 * * 例如 AR 用画像识别 * 例如数据库访问 */ /** * 长时间处理结束,主线程使用该处理结果 */ [self performSelectorOnMainThread:@selector(doneWork) withObject:nil waitUntilDone:NO]; [pool drain];&#125;- (void)doneWork&#123; /** * 只有在主线程可以执行的处理 * * 例如用户界面更新 */&#125; 多线程执行原理总结1234单核CPU同一时间,CPU只能处理1个线程,只有1个线程在执行任务.多线程的同时执行 : 其实是CPU在多条线程之间快速切换(调度任务).如果CPU调度线程的速度足够快,就造成了多线程同时执行的假象.在多核CPU的情况下,就真正并行执行多个线程. 因为长时间的处理(耗时操作),会妨碍主线程的运行循环的执行,所以需要进行多线程编程,如:异步创建子线程去处理耗时操作,耗时操作结束后,再回到主线程刷新UI.这种方式不会妨碍主线程的运行循环的执行,并能提高程序响应性能.如图: CCD的API.Dispatch Queue开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue中.源代码表示:123456dispatch_async(queue, ^&#123; /** * 想执行的任务 */&#125;); Dispatch Queue是执行处理的等待队列.Dispatch Queue按照追加的顺序(先进先出FIFO,First-In-First-Out)执行处理.如图: Dispatch Queue分为4种队列,分别是Serial Queue(串行队列)、Concurrent Queue(并发队列)、Main Dispatch Queue(主调度队列)、Global Dispatch Queue(全局并发队列). 根据官方文档Dispatch Queues中的描述: 1.Serial Queue Serial queues (also known as private dispatch queues) execute one task at a time in the order in which they are added to the queue.If you create four serial queues, each queue executes only one task at a time but up to four tasks could still execute concurrently, one from each queue. 翻译如下: 串行队列（也称为私有调度队列）按顺序将其中一个任务添加到队列中,并且一次只执行一个任务.如果创建四个串行队列,每个队列一次只执行一个任务,但最多四个任务可以并发执行,每个队列中有一个任务. 如图: 代码:12345678910111213141516171819dispatch_queue_t queue = dispatch_queue_create("mySerialDispatchQueue", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; NSLog(@"一个丁老头,欠我两个蛋"); &#125;); dispatch_async(queue, ^&#123; NSLog(@"他说三天还,四天还没还"); &#125;); dispatch_async(queue, ^&#123; NSLog(@"仔细想一想,就是大傻蛋"); &#125;); dispatch_async(queue, ^&#123; NSLog(@"买了三根葱,花了3毛3"); &#125;); dispatch_async(queue, ^&#123; NSLog(@"买个大西瓜,用了6毛6"); &#125;); dispatch_async(queue, ^&#123; NSLog(@"买串糖葫芦,没了7毛7"); &#125;); 根据串行队列特点,从上到下执行每个block中的任务,即丁老头,再还钱,再到大傻蛋,同时执行的处理只有1个.结果如下: 2.Concurrent Queue Concurrent queues (also known as a type of global dispatch queue) execute one or more tasks concurrently, but tasks are still started in the order in which they were added to the queue. The currently executing tasks run on distinct threads that are managed by the dispatch queue. 翻译如下: 并发队列（也称为全局调度队列）同时执行一个或多个任务，但任务仍然按照它们添加到队列的顺序执行.当前执行的任务运行在不同线程上,而这些线程由调度队列所管理. 如图: 将DISPATCH_QUEUE_SERIAL更改为DISPATCH_QUEUE_CONCURRENT. 代码:1dispatch_queue_t queue = dispatch_queue_create("myConcurrentDispatchQueue", DISPATCH_QUEUE_CONCURRENT); 那么丁老头的执行顺序就是不确定的,即并行执行.注意:在不能改变执行的处理顺序或不想并行执行多个处理时使用Serial Dispatch Queue. 3.Main Dispatch Queue The main dispatch queue is a globally available serial queue that executes tasks on the application’s main thread. This queue works with the application’s run loop (if one is present) to interleave the execution of queued tasks with the execution of other event sources attached to the run loop. 翻译如下: 主调度队列是一个全局可用的串行队列,它在应用程序的主线程上执行任务.该队列与应用程序的运行循环（如果有的话）一起工作,即该队列的任务与运行循环的其他事件源交叉执行. 如图: 4.Global Dispatch Queue The system provides each application with four concurrent dispatch queues. These queues are global to the application and are differentiated only by their priority level. Because they are global, you do not create them explicitly. Instead, you ask for one of the queues using the dispatch_get_global_queue function 翻译如下: 系统为每个应用程序提供四个并发调度队列.这些队列对应用程序而言是全局的,而且只对它们的优先级进行区分.因为它们是全局的，所以不需要明确地创建它们.相反,你可以用dispatch_get_global_queue函数的获取其中一个队列. 优先级如下: 名称 Dispatch Queue的种类 说明 Main Dispatch Queue Serial Diapatch Queue 主线程执行 Global Dispatch Queue(High Priority) Concurrent Dispatch Queue 执行优先级:高(最高优先级) Global Dispatch Queue(Default Priority) Concurrent Dispatch Queue 执行优先级:默认 Global Dispatch Queue(Low Priority) Concurrent Dispatch Queue 执行优先级:低 Global Dispatch Queue(Background Priority) Concurrent Dispatch Queue 执行优先级:后台 代码:12345678910// 主队列dispatch_queue_t mainDiapatchQueue = dispatch_get_main_queue();// 高优先级全局并发队列dispatch_queue_t globalDiapatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);// 默认先级全局并发队列dispatch_queue_t globalDiapatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 低优先级全局并发队列dispatch_queue_t globalDiapatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);// 后台先级全局并发队列dispatch_queue_t globalDiapatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); 总结: 串行队列串行队列里面的任务,都是按顺序依次调度执行,前面一个任务未执行完,后面的任务不会被调度执行. 并发队列 == 全局并发队列可以同时调度多个任务同时的执行. 主队列主队列由系统创建好的,可直接获取.主队列中的任务,一定是在主线程中执行.主要进行线程间的通信.只有在主线程空闲的时候,主队列才会调度其中的任务执行. 全局队列全局队列又叫全局并发队列.由系统创建,可直接获取,调度任务的效果等同于并发队列. dispatch_queue_create该ApI主要是为了生成dispatch queue.代码:12345678/** * 第1个参数:指定队列的名称 * 第2个参数:指定队列的类型 */// 生成串行队列dispatch_queue_t mySerialDiapatchQueue = dispatch_queue_create("MySerialDiapatchQueue", DISPATCH_QUEUE_SERIAL);// 生成并发队列dispatch_queue_t myConcurrentDiapatchQueue = dispatch_queue_create("MyConcurrentDiapatchQueue", DISPATCH_QUEUE_CONCURRENT); 因为一个串行队列,只生成并使用一个线程,所以创建几个串行队列就生成几个线程,线程过多,会消耗大量内存,影响系统响应性能. 问题:多个线程竞争同一资源时,会出现数据安全问题. 例子:线程A、线程B、线程C都准备使用数据data,data的值为36,线程A先将data值从36改为20,此时线程B要使用data,他要读取data值,在正常情况下,线程B读取到的值应该为36,但是data的值在线程A中被改成20,导致线程B获取到data值不正确.C的事就不说了,我B都错了,难道你C还想要对的数据? 解决:使用Serial Diapatch Queue可以保证数据的安全. 例子:还是A、B、C三兄弟,A在用data,B也想用data,但是B只能乖乖等着,A用完data,data值是否改变不重要,因为,B这时候用的是A的结果.不会产生安全问题.好像C就是打酱油的,没排上用场,好吧,此处省略C一万字... 书中提及:虽然存在ARC自动管理内存,但是生成的Dispatch Queue必须由程序员负责释放.所以我测试了,在ARC环境下,用书中方法对队列进行release操作,但是提示ARC forbids explicit message send of &#39;release&#39;错误,所以ARC已经对队列进行了引用计数的增减,不需要我们手动release了. dispatch_set_target_queue该API主要用于变更生成的队列的执行优先级的.通过dispatch_queue_create生成的队列,不论串行队列还是并发队列,它们与默认优先级的全局并发队列的优先级相同.所以,可以通过dispatch_set_target_queue,将串行队列的优先级改为在后台执行.代码:12345678910// 串行队列dispatch_queue_t mySerialDiapatchQueue = dispatch_queue_create("MySerialDiapatchQueue", DISPATCH_QUEUE_SERIAL);// 后台先级全局并发队列dispatch_queue_t globalDiapatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);/** * 第1个参数:准备变更优先级的队列 * 第2个参数:变更后的相同优先级的的队列 */// 变更优先级dispatch_set_target_queue(mySerialDiapatchQueue, globalDiapatchQueueBackground); 书中提及此方法的作用:多个串行队列,假设有3个串行队列A、B、C,A、B、C串行队列原本是并行执行的,每个队列执行自己的一个任务.但是通过dispatch_set_target_queue方法,将A的优先级设置成B的优先级,此时,只能执行A中的任务.因此这种方法,可以防止处理并行执行. dispatch_afterdispatch_after这个是大家常用的API,主要进行延迟操作.但是延迟只说明再一定时间后,将任务添加到队列中执行,真正开始执行任务,可能因为主线程本身的处理有延迟,导致时间不准确.代码1234567891011/** * dispatch_time:获取dispatch_time_t类型的时间 * DISPATCH_TIME_NOW:当前时间 * NSEC_PER_SEC:单位秒 */dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3ull * NSEC_PER_SEC)); // dispatch_after:在3秒后,将任务添加到队列中 dispatch_after(time, dispatch_get_main_queue(), ^&#123; NSLog(@"wait at least three second"); &#125;); 附上第2个参数的时间说明12345678NSEC：纳秒USEC：微妙SEC：秒PER：每#define NSEC_PER_SEC 1000000000ull 每秒有多少纳秒#define NSEC_PER_MSEC 1000000ull 每毫秒有多少纳秒#define USEC_PER_SEC 1000000ull 每秒有多少微秒#define NSEC_PER_USEC 1000ull 每微妙有多少纳秒 dispatch groupdispatch group即调度组.作用:调度组中的所有异步任务执行结束之后,会得到统一的通知. 使用场景监听一组异步任务是否执行结束,如果执行结束就能够得到统一的通知. 1234567891011121314151617// 创建默认优先级的全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);// 创建调度组dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; NSLog(@"下载图片A");&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@"下载图片B");&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@"下载图片C");&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"处理下载完成的图片");&#125;); 打印结果:12342017-07-01 13:26:15.620007+0800 BYGCDDemo[368:102016] 下载图片B2017-07-01 13:26:15.620175+0800 BYGCDDemo[368:102016] 下载图片C2017-07-01 13:26:15.620219+0800 BYGCDDemo[368:102016] 下载图片A2017-07-01 13:26:15.635798+0800 BYGCDDemo[368:101977] 处理下载完成的图片 或12342017-07-01 13:26:15.620007+0800 BYGCDDemo[368:102016] 下载图片C2017-07-01 13:26:15.620175+0800 BYGCDDemo[368:102016] 下载图片B2017-07-01 13:26:15.620219+0800 BYGCDDemo[368:102016] 下载图片A2017-07-01 13:26:15.635798+0800 BYGCDDemo[368:101977] 处理下载完成的图片 总之,下载图片A、B、C是并行执行顺序不一,但是,处理下载完成的图片的操作一定是在最后执行,且只在A、B、C操作结束后,调度组收到结束通知,才去执行处理下载完成的图片. 可以使用dispatch_group_wait方法实现以上相同功能12345678910111213141516171819202122232425dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123; NSLog(@"下载图片A");&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@"下载图片B");&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@"下载图片C");&#125;);/** * 第1个参数:执行任务的调度组 * 第2个参数:等待时间 */long result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);if (result == 0)&#123; NSLog(@"处理下载完成的图片");&#125;else&#123; NSLog(@"以上调度组中存在未完成的任务");&#125; 当调度组中的方法未执行完成,dispatch_group_wait方法中的DISPATCH_TIME_FOREVER属于永久等待状态,且dispatch_group_wait只调用不返回,即result的值恒不等0,执行dispatch_group_wait方法所在的线程停止,直到调度组中的任务完成,执行dispatch_group_wait方法所在的线程开始工作,result为0,所以可以根据result值判断,图片是否下载完成. 若将以上代码中的DISPATCH_TIME_FOREVER更改为DISPATCH_TIME_NOW,那么当程序执行到dispatch_group_wait方法,直接进行判断,而不用等待.此时,A、B、C的下载工作可能都还没执行完,就出现下列结果:12342017-07-01 14:52:14.498329+0800 BYGCDDemo[421:115796] 以上调度组中存在未完成的任务2017-07-01 14:52:14.498421+0800 BYGCDDemo[421:115825] 下载图片B2017-07-01 14:52:14.498473+0800 BYGCDDemo[421:115825] 下载图片C2017-07-01 14:52:14.498350+0800 BYGCDDemo[421:115828] 下载图片A 不过推荐使用dispatch_group_notify方法,主要是简化代码. dispatch_barrier_asyncdispatch_barrier_async在并发执行任务的队列中追加处理任务,该任务在等待前面并发任务执行完成之后才执行,当dispatch_barrier_async中的任务执行完成,才会继续执行后续的并发执行的任务. 如图: 代码: 12345678910111213141516dispatch_queue_t queue = dispatch_queue_create("MyConcurrentDiapatchQueue", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123; NSLog(@"第1次读取data值");&#125;);dispatch_async(queue, ^&#123; NSLog(@"第2次读取data值");&#125;);dispatch_async(queue, ^&#123; NSLog(@"第1次写入data值");&#125;);dispatch_async(queue, ^&#123; NSLog(@"第3次读取data值");&#125;);dispatch_async(queue, ^&#123; NSLog(@"第4次读取data值");&#125;); 分析:假设,data初始值为36,因为这些任务是并发执行的,可能先执行了第1次写入data值,写入之后的值为20之后再进行第1次读取data值,导致读取到值20与期望值36不符合,所以为了避免这种情况发生,将第1次写入data值的方法改为:dispatch_barrier_async,这样,程序先并发执行第1次读取data值和第2次读取data值,等待这两个任务执行完成,才开始dispatch_barrier_async中的任务,当dispatch_barrier_async中的任务完成后,继续并发执行第3次读取data值和第4次读取data值.这样既保证了前两次读取数据的正确以及第1次写入操作的成功,也保证后续读取操作能正确读取被改写过的值. 总结:dispatch_barrier_async 方法可实现高效率数据库的数据访问和文件访问. dispatch_syncdispatch_sync方法意味着同步,即将指定的任务同步地添加到指定的队列中,在追加其他任务之前,会一直等待.在主线程中调用dispatch_sync方法会引起死锁问题.代码:1234dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^&#123; NSLog(@"我非要在主队列中执行同步任务"); &#125;); 或12345678dispatch_queue_t queue = dispatch_get_main_queue();dispatch_async(queue, ^&#123; dispatch_sync(queue, ^&#123; NSLog(@"我非要在主队列中执行同步任务"); &#125;);&#125;); 分析:在上文主队列的概念中提到,只有在主线程空闲的时候,才会执行主队列中的任务.仔细查看以上两种方法,当主队列想要执行队列中的block,就必须等待主线程空闲,但是,此时主队列的代码正在主线程中运行,所以主线程是不空闲,既然不空闲,那么主队列的block就无法执行.一句话就是:主队列的block等待主线程空闲,但主队列自己却占着主线程的位置. 建议使用:dispatch_async + 主队列. dispatch_applydispatch_apply也会等待全部处理执行结束.代码:12345678910/** * 第1个参数:重复的次数 * 第2个参数:执行任务的队列 * 第3个参数:追加的处理 */dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply(10, queue, ^(size_t index) &#123; NSLog(@"%zu",index);&#125;);NSLog(@"done"); 结果:12345678910114103526897done 第3个参数是带有参数的block,为了区分追加到队列中block.如果对数组中的每个对象进行处理.推荐使用以下方法:1234567891011121314NSArray *arr = [NSArray arrayWithObjects:@"10",@"20",@"30", nil];dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(queue, ^&#123; // 等待 dispatch_apply 方法中全部处理执行结束 dispatch_apply(arr.count, queue, ^(size_t index) &#123; // 并列处理包含在数组中全部对象 NSLog(@"%zu:%@",index,[arr objectAtIndex:index]); &#125;); dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@"用户界面更新"); &#125;);&#125;); dispatch_suspenddispatch_suspend挂起队列,表示队列中还未执行的任务会暂停,已经执行的任务会继续执行.1dispatch_suspend(queue); dispatch_resumedispatch_suspend恢复队列,表示队列中还未执行的任务会恢复执行.1dispatch_resume(queue); dispatch semaphoredispatch semaphore是持有计数的信号.计数为0等待,计数为1或大于1,减去1而不等待.dispatch semaphore创建方式:12// 1表示计数的初始值dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); 遇到以下情况:12345678910dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);NSMutableArray *arr = [[NSMutableArray alloc] init];for (int i = 0; i &lt; 10000; i++)&#123; dispatch_async(queue, ^&#123; [arr addObject:[NSNumber numberWithInt:i]]; &#125;);&#125; 开启太多子线程,势必导致程序响应问题,以及内存错误,导致崩溃.解决:123456789101112131415161718192021222324252627282930313233343536dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);/** * 生成dispatch semaphore * * dispatch semaphore的计数初始值为1 * * 保证可同时访问NSMutableArray类对象的线程 * 同时只能有一个 */dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);NSMutableArray *arr = [[NSMutableArray alloc] init];for (int i = 0; i &lt; 10000; i++)&#123; dispatch_async(queue, ^&#123; /** * 等待dispatch semaphore * * 一直等待,直到计数值大于等于1 */ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); /** * 由于dispatch semaphore的计数值大于等于1 * 所以将dispatch semaphore的计数值减去1 * dispatch_semaphore_wait方法执行返回 * * 执行到此时的dispatch semaphore的计数恒为0 * 由于可访问NSMutableArray类对象的线程只有1个 * 因此可安全地进行更新 */ [arr addObject:[NSNumber numberWithInt:i]]; // dispatch_semaphore_signal 方法将dispatch semaphore的计数加1. dispatch_semaphore_signal(semaphore); &#125;);&#125; 分析:通过计数值去判断当前线程能否处理数组对象,计数初始值是1,跳过dispatch_semaphore_wait方法,处理对象之后,再减去1,值为0,此时若继续添加线程,肯定无法跳过dispatch_semaphore_wait方法,只能等待上一个线程通过dispatch_semaphore_signal方法把计数值改成1,即上一个线程已经完成对数组的处理,才能开始下一个线程的处理任务. dispatch_once这是常用来创建单例的方法.12345static ViewController *instance;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; instance = [[ViewController alloc] init];&#125;); 分析:在执行到dispatch_once(&amp;onceToken, ^{时打断点,可以看到onceToken结果是0,但是在末行});打断点,结果是1027,这个值是不确定,所以,每次执行dispatch_once时,都会判断onceToken的值,如果是0,执行block中的代码,非0,则不执行,达到创建单例的效果. CCD的实现.用于实现Dispatch Queue而使用的软件组件. 组件名称 提供技术 libdispatch Diapatch Queue Libc ( pthreads ) pthread_workqueue XNU 内核 workqueue GCD的API全部为在libdispatch库中的C语言函数.Dispatch Queue执行步骤:1.GCD初始化时,使用pthread_workqueue_create_np函数生成pthead_workqueue.pthead_workqueue包含在Libc提供的ptheads API,它使用bsdthead_register和workq_open系统调用.2.dispatch queue通过结构体和链表,被实现为FIFO队列.block不是直接加入FIFO队列.它先加入dispatch continuation这一dispatch_continuation_t类型结构体中,然后再加入FIFO队列.3.当在global dispatch queue中执行block时,libdispatch从global dispatch queue自身的FIFO队列中取出dispatch continuation,调用pthread_workqueue_additem_np函数.将global dispatch queue自身、符合其优先级的workqueue信息以及为执行dispatch continuation的回调函数传递给参数.4.pthread_workqueue_additem_np函数使用workq_kernreturn系统调用,通知workqueue增加应当执行的项目.根据该通知,XNU内核基于系统状态判断是否要生成线程.如果是OverCommit优先级的global dispatch queue,workqueue则始终生成线程.5.workqueue的线程执行pthread_workqueue函数,该函数调用libdispatch的回调函.在该回调函数中中执行加入到dispatch continuation的block.6.block执行结束后,进行通知dispatch group结束、释放dispatch continuation等处理,开始准备执行加入到global dispatch queue中的下一个block. 简书iOS读书笔记之Objective-C高级编程(GCD)]]></content>
      <categories>
        <category>iOS读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建]]></title>
    <url>%2F2017%2F06%2F10%2FHexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开始安装1$ npm install -g hexo 出错,使用淘宝镜像1$ npm config set registry https://registry.npm.taobao.org 出现权限不允许,修改该文件的权限:/usr/local/lib/node_modules,找到文件夹右击,权限改为:读与写创建一个文件夹名为:Blog,cd到Blog文件夹中1$ cd /Users/lbymac/Blog 初始化hex1$ hexo init 文件生成1$ hexo generate 本地服务测试1$ hexo server 在_config.yml文件中添加以下信息123type: git repository: https://github.com/CherishJoyBy/CherishJoyBy.github.io.gitbranch: master git上传插件安装1$ npm install hexo-deployer-git —save 清空1$ hexo clean 生成1$ hexo generate 部署上传1$ hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之CocoaAsyncSocket使用]]></title>
    <url>%2F2017%2F06%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BCocoaAsyncSocket%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了CocoaAsyncSocket库中GCDAsyncSocket类的使用、粘包处理以及时间延迟测试. 一.CocoaAsyncSocket介绍CocoaAsyncSocket中主要包含两个类: 1.GCDAsyncSocket. 用GCD搭建的基于TCP/IP协议的socket网络库GCDAsyncSocket is a TCP/IP socket networking library built atop Grand Central Dispatch. – 引自CocoaAsyncSocket. 2.GCDAsyncUdpSocket. 用GCD搭建的基于UDP/IP协议的socket网络库.GCDAsyncUdpSocket is a UDP/IP socket networking library built atop Grand Central Dispatch..– 引自CocoaAsyncSocket. 二.下载CocoaAsyncSocket首先,需要到这里下载CocoaAsyncSocket.下载后可以看到文件所在位置. 这里只要拷贝以下两个文件到项目中. 三.客户端因为,大部分项目已经有服务端socket,所以,先讲解客户端创建过程. 步骤:1.继承GCDAsyncSocketDelegate协议.2.声明属性12// 客户端socket@property (strong, nonatomic) GCDAsyncSocket *clientSocket; 3.创建socket并指定代理对象为self,代理队列必须为主队列.1self.clientSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()]; 4.连接指定主机的对应端口.12NSError *error = nil;self.connected = [self.clientSocket connectToHost:self.addressTF.text onPort:[self.portTF.text integerValue] viaInterface:nil withTimeout:-1 error:&amp;error]; 5.成功连接主机对应端口号.123456789101112- (void)socket:(GCDAsyncSocket *)sock didConnectToHost:(NSString *)host port:(uint16_t)port &#123;// NSLog(@"连接主机对应端口%@", sock); [self showMessageWithStr:@"链接成功"]; [self showMessageWithStr:[NSString stringWithFormat:@"服务器IP: %@-------端口: %d", host,port]]; // 连接成功开启定时器 [self addTimer]; // 连接后,可读取服务端的数据 [self.clientSocket readDataWithTimeout:- 1 tag:0]; self.connected = YES;&#125; 注意:The host parameter will be an IP address, not a DNS name. – 引自GCDAsyncSocket连接的主机为IP地址,并非DNS名称. 6.发送数据给服务端12345678// 发送数据- (IBAction)sendMessageAction:(id)sender&#123; NSData *data = [self.messageTextF.text dataUsingEncoding:NSUTF8StringEncoding]; // withTimeout -1 : 无穷大,一直等 // tag : 消息标记 [self.clientSocket writeData:data withTimeout:- 1 tag:0];&#125; 注意:发送数据主要通过- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag写入数据的. 7.读取服务端数据1234567891011121314/** 读取数据 @param sock 客户端socket @param data 读取到的数据 @param tag 本次读取的标记 */- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag &#123; NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showMessageWithStr:text]; // 读取到服务端数据值后,能再次读取 [self.clientSocket readDataWithTimeout:- 1 tag:0];&#125; 注意:有的人写好代码,而且第一次能够读取到数据,之后,再也接收不到数据.那是因为,在读取到数据的代理方法中,需要再次调用[self.clientSocket readDataWithTimeout:- 1 tag:0];方法,框架本身就是这么设计的. 8.客户端socket断开连接.1234567891011121314/** 客户端socket断开 @param sock 客户端socket @param err 错误描述 */- (void)socketDidDisconnect:(GCDAsyncSocket *)sock withError:(NSError *)err&#123; [self showMessageWithStr:@"断开连接"]; self.clientSocket.delegate = nil; self.clientSocket = nil; self.connected = NO; [self.connectTimer invalidate];&#125; 注意:sokect断开连接时,需要清空代理和客户端本身的socket.12self.clientSocket.delegate = nil;self.clientSocket = nil; 9.建立心跳连接.1234567891011121314151617181920212223 // 计时器@property (nonatomic, strong) NSTimer *connectTimer;// 添加定时器- (void)addTimer&#123; // 长连接定时器 self.connectTimer = [NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(longConnectToSocket) userInfo:nil repeats:YES]; // 把定时器添加到当前运行循环,并且调为通用模式 [[NSRunLoop currentRunLoop] addTimer:self.connectTimer forMode:NSRunLoopCommonModes];&#125;// 心跳连接- (void)longConnectToSocket&#123; // 发送固定格式的数据,指令@"longConnect" float version = [[UIDevice currentDevice] systemVersion].floatValue; NSString *longConnect = [NSString stringWithFormat:@"123%f",version]; NSData *data = [longConnect dataUsingEncoding:NSUTF8StringEncoding]; [self.clientSocket writeData:data withTimeout:- 1 tag:0];&#125; 注意:心跳连接中发送给服务端的数据只是作为测试代码,根据你们公司需求,或者和后台商定好心跳包的数据以及发送心跳的时间间隔.因为这个项目的服务端socket也是我写的,所以,我自定义心跳包协议.客户端发送心跳包,服务端也需要有对应的心跳检测,以此检测客户端是否在线. 四.服务端步骤:1.继承GCDAsyncSocketDelegate协议.2.声明属性12// 服务端socket(开放端口,监听客户端socket的连接)@property (strong, nonatomic) GCDAsyncSocket *serverSocket; 3.创建socket并指定代理对象为self,代理队列必须为主队列.12// 初始化服务端socketself.serverSocket = [[GCDAsyncSocket alloc]initWithDelegate:self delegateQueue:dispatch_get_main_queue()]; 4.开放服务端的指定端口.1BOOL result = [self.serverSocket acceptOnPort:[self.portF.text integerValue] error:&amp;error]; 5.连接上新的客户端socket12345678910111213// 连接上新的客户端socket- (void)socket:(GCDAsyncSocket *)sock didAcceptNewSocket:(nonnull GCDAsyncSocket *)newSocket&#123; // 保存客户端的socket [self.clientSockets addObject: newSocket]; // 添加定时器 [self addTimer]; [self showMessageWithStr:@"链接成功"]; [self showMessageWithStr:[NSString stringWithFormat:@"客户端的地址: %@ -------端口: %d", newSocket.connectedHost, newSocket.connectedPort]]; [newSocket readDataWithTimeout:- 1 tag:0];&#125; 6.发送数据给客户端1234567891011// socket是保存的客户端socket, 表示给这个客户端socket发送消息- (IBAction)sendMessage:(id)sender&#123; if(self.clientSockets == nil) return; NSData *data = [self.messageTextF.text dataUsingEncoding:NSUTF8StringEncoding]; // withTimeout -1 : 无穷大,一直等 // tag : 消息标记 [self.clientSockets enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj writeData:data withTimeout:-1 tag:0]; &#125;];&#125; 7.读取客户端的数据123456789101112131415161718192021222324252627/** 读取客户端发送的数据 @param sock 客户端的Socket @param data 客户端发送的数据 @param tag 当前读取的标记 */- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag&#123; NSString *text = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; [self showMessageWithStr:text]; // 第一次读取到的数据直接添加 if (self.clientPhoneTimeDicts.count == 0) &#123; [self.clientPhoneTimeDicts setObject:[self getCurrentTime] forKey:text]; &#125; else &#123; // 键相同,直接覆盖,值改变 [self.clientPhoneTimeDicts enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; [self.clientPhoneTimeDicts setObject:[self getCurrentTime] forKey:text]; &#125;]; &#125; [sock readDataWithTimeout:- 1 tag:0];&#125; 8.建立检测心跳连接.12345678910111213141516171819202122232425262728293031// 检测心跳计时器@property (nonatomic, strong) NSTimer *checkTimer;// 添加计时器- (void)addTimer&#123; // 长连接定时器 self.checkTimer = [NSTimer scheduledTimerWithTimeInterval:10.0 target:self selector:@selector(checkLongConnect) userInfo:nil repeats:YES]; // 把定时器添加到当前运行循环,并且调为通用模式 [[NSRunLoop currentRunLoop] addTimer:self.checkTimer forMode:NSRunLoopCommonModes];&#125;// 检测心跳- (void)checkLongConnect&#123; [self.clientPhoneTimeDicts enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 获取当前时间 NSString *currentTimeStr = [self getCurrentTime]; // 延迟超过10秒判断断开 if (([currentTimeStr doubleValue] - [obj doubleValue]) &gt; 10.0) &#123; [self showMessageWithStr:[NSString stringWithFormat:@"%@已经断开,连接时差%f",key,[currentTimeStr doubleValue] - [obj doubleValue]]]; [self showMessageWithStr:[NSString stringWithFormat:@"移除%@",key]]; [self.clientPhoneTimeDicts removeObjectForKey:key]; &#125; else &#123; [self showMessageWithStr:[NSString stringWithFormat:@"%@处于连接状态,连接时差%f",key,[currentTimeStr doubleValue] - [obj doubleValue]]]; &#125; &#125;];&#125; 心跳检测方法只提供部分思路:1.懒加载一个可变字典,字典的键作为客户端的标识.如:客户端标识为13123456789. 2.在- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag方法中,将读取到的数据或者数据中的部分字符串作为键.字典的值为系统当前时间.服务端第一次读取数据时,字典中没有数据,所以,直接添加到可变字典中,之后每次读取数据时,都用字典的setObject: forKey:方法添加字典,若存储的键相同,即客户端标识相同,键会被覆盖,再使用系统的当前时间作为值. 3.在- (void)checkLongConnect中,获取此时的当前时间,遍历字典,将每个键的值和当前时间进行比较即可.判断的延迟时间可以写8秒.时间自定.之后,再根据自己的需求进行后续处理. 五.数据粘包处理.1.粘包情况.例如:包数据为:abcd. 接收类型 第1次接收 第2次接收 第3次接收 完整型 abcd abcdabcd abcdabcdabcd 多余型 abcdab cdabcdab cdabcdabcdab 不完整型 ab cda bcdabc 2.粘包解决思路.思路1:发送方将数据包加上包头和包尾,包头、包体以及包尾用字典形式包装成json字符串,接收方,通过解析获取json字符串中的包体,便可进行进一步处理.例如:1234567&#123;// head:包头,body:包体,end:包尾 NSDictionary *dict = @&#123; @"head" : @"phoneNum", @"body" : @(13133334444), @"end" : @(11)&#125;; &#125; 思路2:添加前缀.和包内容拼接成同一个字符串. 例如:当发送数据是13133334444,如果出现粘包情况只属于完整型:131333344441313333444413133334444131333344441313333444413133334444…可以将ab作为前缀.则接收到的数据出现的粘包情况:ab13133334444ab13133334444ab13133334444ab13133334444ab13133334444ab13133334444…使用componentsSeparatedByString:方法,以ab为分隔符,将每个包内容存入数组中,再取对应数组中的数据操作即可. 思路3:如果最终要得到的数据的长度是个固定长度,用一个字符串作为缓冲池,每次收到数据,都用字符串拼接对应数据,每当字符串的长度和固定长度相同时,便得到一个完整数据,处理完这个数据并清空字符串,再进行下一轮的字符拼接. 例如:处理上面的不完整型.创建一个长度是4的tempData字符串作为数据缓冲池.第1次收到数据,数据是:ab,tempData拼接上ab,tempData中只能再存储2个字符,第2次收到数据,将数据长度和2进行比较,第2次的数据是:cda,截取前两位字符,即cd,tempData继续拼接cd,此时,tempData为abcd,就是我们想要的数据,我们可以处理这个数据,处理之后并清空tempData,将第2次收到数据的剩余数据,即cda中的a,再与tempData拼接.之后,再进行类似操作. 核心代码123456789101112131415161718192021222324252627282930313233343536/** 处理数据粘包 @param readData 读取到的数据 */ - (void)dealStickPackageWithData:(NSString *)readData&#123; // 缓冲池还需要存储的数据个数 NSInteger tempCount; if (readData.length &gt; 0) &#123; // 还差tempLength个数填满缓冲池 tempCount = 4 - self.tempData.length; if (readData.length &lt;= tempCount) &#123; self.tempData = [self.tempData stringByAppendingString:readData]; if (self.tempData.length == 4) &#123; [self.mutArr addObject:self.tempData]; self.tempData = @""; &#125; &#125; else &#123; // 下一次的数据个数比要填满缓冲池的数据个数多,一定能拼接成完整数据,剩余的继续 self.tempData = [self.tempData stringByAppendingString:[readData substringToIndex:tempCount]]; [self.mutArr addObject:self.tempData]; self.tempData = @""; // 多余的再执行一次方法 [self dealStickPackageWithData:[readData substringFromIndex:tempCount]]; &#125; &#125;&#125; 调用12345678910111213141516171819202122// 存储处理后的每次返回数据@property (nonatomic, strong) NSMutableArray *mutArr;// 数据缓冲池@property (nonatomic, copy) NSString *tempData; /** 第四次测试 -- 混合型**/ self.mutArr = nil; /* 第1次 : abc 第2次 : da 第3次 : bcdabcd 第4次 : abcdabcd 第5次 : abcdabcdab */ // 数组中的数据代表每次接收的数据 NSArray *testArr4 = [NSArray arrayWithObjects:@"abc",@"da",@"bcdabcd",@"abcdabcd",@"abcdabcdab", nil]; self.tempData = @""; for (NSInteger i = 0; i &lt; testArr4.count; i++) &#123; [self dealStickPackageWithData:testArr4[i]]; &#125; NSLog(@"testArr4 = %@",self.mutArr); 结果:1234567892017-06-09 00:49:12.932976+0800 StickPackageDealDemo[10063:3430118] testArr4 = ( abcd, abcd, abcd, abcd, abcd, abcd, abcd) 数据粘包处理Demo在文末. 六.测试.1.测试配置.测试时,两端需要处于同一WiFi下.客户端中的IP地址为服务端的IP地址,具体信息进入Wifi设置中查看. 2.测试所需环境.将客户端程序安装在每个客户端,让一台服务端测试机和一台客户端测试机连接mac并运行,这两台测试机可以看到打印结果,所有由服务端发送到客户端的数据,通过客户端再回传给服务端,在服务端看打印结果. 3.进行延迟差测试.延迟差即服务端发送数据到第一台客户端和服务端发送数据到最后一台客户端的时间差.根据服务端发送数据给不同数量的客户端进行测试.而且,发送数据时,是随机发送. 延迟差测试结果: 由图所知,延迟差在200毫秒以内的比例基本保持在99%以上.所以符合开发需求(延迟在200毫秒以内). 4.单次信息收发测试.让服务端给每个客户端随机发送200次数据.并计算服务端发送数据到某一客户端,完整的一次收发时间情况. 单次信息收发测试结果: 由图所知,一次收发时间基本在95%以上,这个时间会根据网络状态和数据包大小波动.不过,可以直观看到数据从服务端到客户端的时间. GitHub数据粘包处理DemoCocoaAsyncSocket客户端DemoCocoaAsyncSocket服务端DemoCocoaAsyncSocket客户端Demo(含粘包解决和测试)CocoaAsyncSocket服务端Demo(含粘包解决和测试) 简书iOS开发之CocoaAsyncSocket使用]]></content>
      <categories>
        <category>iOS第三方使用</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaAsyncSocket</tag>
        <tag>TCP</tag>
        <tag>粘包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown之简书书写换行代码缩进]]></title>
    <url>%2F2017%2F06%2F06%2FMarkdown%E4%B9%8B%E7%AE%80%E4%B9%A6%E4%B9%A6%E5%86%99%E6%8D%A2%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%BC%A9%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[本文介绍了简书书写换行代码缩进的方法.初次使用简书的富文本写技术类的文章时,容易出现换行代码块错乱的问题. 一.单纯的换行.代码块上的标题没有以下格式. 注意:圆点由-、*、+等产生. 简书代码: 显示效果: 二.标题带有圆点格式换行.代码块上的标题含有以下格式. 简书代码: 显示效果: 三.解决.使用tab键将以下各行向右缩进一个单位. 显示效果: 提示:多尝试,多摸索,你会发现,只要用tab键将int b = 1;所在行向右缩进一个单位即可.如果复制的代码来源中,本身带有空行的,在简书中可以自动显示为空行,而不需要调格式. 四.文本段落需要带有大于号(&gt;)的时候.简书代码: 显示效果: 五.解决.每行首个字符前加上&gt;号. 简书代码: 显示效果: 再用tab键从&gt;之后将int b = 0所在行向右缩进一个单位. 简书代码: 显示效果: 提示:多尝试,多摸索,你会发现,只要在int b = 1;所在行添加&gt;,之后从&gt;后面向右缩进一个单位即可. 简书Markdown之简书书写换行代码缩进]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>简书</tag>
        <tag>缩进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之host配置]]></title>
    <url>%2F2017%2F06%2F06%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8Bhost%E9%85%8D%E7%BD%AE(Mac)%2F</url>
    <content type="text"><![CDATA[本文介绍了host的配置过程. 一.打开 Finder,快捷键Command + Shift + G.弹出文本框.二.在路径中输入/private.点击前往. 三.选择etc文件. 四.然后按h键,hosts文件就出现了.不用拖动滚动条来回查找. 五.想要修改hosts文件,需要修改etc和hosts两个文件的权限.右击etc,点击显示简介. 六.点击右下角的🔐. 七.输入mac开机密码,点击好. 八.将everyone的权限改为读与写. 九.hosts权限修改类似.打开hosts文件,便可以往其中添加内容了.注意:记得修改完权限,还原为只读权限. 简书iOS开发之host配置]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>host配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS常见问题之苹果证书无法导出p12格式的文件]]></title>
    <url>%2F2017%2F06%2F06%2FiOS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B9%8B%E8%8B%B9%E6%9E%9C%E8%AF%81%E4%B9%A6%E6%97%A0%E6%B3%95%E5%AF%BC%E5%87%BAp12%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本文介绍了苹果证书无法导出p12格式的文件的解决方法. 一.打开钥匙串导出证书的默认界面,发现p12选项为灰色,无法选择. 说明:我对这种情况的证书进行测试,将直接导出.cer的证书,拷贝到其他电脑上并安装,打包项目时,提示:1No valid signing identities matching the team ID "xxx" were found. 在项目中,快捷键 command + ,选择对应的AppleIDs,再选择对应的Team,点击ManageCertificates,可以看到证书报一个错误,这个错误就是由于安装.cer证书导致的.1Missing private key 二.打开钥匙串之后,选择种类,然后选择证书,再找到对应要导出的证书. 三.结果出现p12的选项. 四.导出后,设置对应密码,再拷贝到其他电脑上安装证书.便能正常打包程序.简书iOS常见问题之苹果证书无法导出p12格式的文件]]></content>
      <categories>
        <category>iOS常见问题</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>常见问题</tag>
        <tag>p12</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之App上架流程(2017)]]></title>
    <url>%2F2017%2F05%2F17%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BApp%E4%B8%8A%E6%9E%B6%E6%B5%81%E7%A8%8B(2017)%2F</url>
    <content type="text"><![CDATA[本文主要介绍了App上架流程,以及上架过程中会遇到的一些问题. 一.App上架前的准备.上架前,需要开发人员有苹果开发者账号,具体请阅读苹果开发者账号注册申请流程.本文是在已经拥有开发者账号的前提下而开展的. 二.登陆苹果开发者官网.1.进入苹果开发者官网. 2.点击Acount. 3.输入开发者账号,点击Sign in(登陆) 三.生成发布证书1.点击Certifcates,Identifiers &amp; Profiles(证书,id,配置) 2.点击All,再点击”+”号,添加发布证书. 3.选择App Store and Ad Hoc.之后continue. 4.还是continue. 5.这里需要选择CSR文件. 6.打开钥匙串,钥匙串在Launchpad的Other文件夹中 7.点击钥匙串访问 -&gt; 证书助理 -&gt;从证书颁发机构请求证书. 8.电子邮件地址随意填写,邮箱常用名可不填,存储到磁盘. 9.存储在磁盘上的CSR文件 10.将CSR上传苹果服务器 11.点击Download下载CER文件,保存并双击运行,运行完成后,点击Done. 12.运行之后,在钥匙串里生成证书,确保证书有效. 四.创建App IDs并绑定App的Bundle Identifier1.点击App IDs,点击”+”号. 2.填写AppID 和 Bundle Identifier,name可以根据公司项目名来填写,日期只是为了标记这个App ID创建的时间.建议填写.Bundle Identifier则为项目的Bundle ID. 3.选择App Services,默认为两项,(根据具体需求选择),点击continue完成创建. 4.点击Register 5.点击Done 6.注册成功后内容 注意:1.上传App所用的Bundle Identifier为英文 + 数字的组合,而且是固定的,不能使用占位符和特殊符号.2.如果工程中的Bundle Identifier改变,则开发者账号中添加的App ID需要重新绑定. 五.生成描述文件1.描述文件是描述哪台电脑能对哪个Bundle Identifier的工程进行打包测试或发布.点击Provisioning Profiles,点击All,再点击右上角”+”号. 2.如果是发布,选择App Store这个描述文件,英译为:创建发布描述文件以提交你的app到App Store;如果仅是安装到不同手机上进行测试,选择Ad Hoc,英译为:创建发布描述文件以安装你的app到已经注册的设备上(注册的设备上限为100台),点击Continue. 3.在App ID这个选项栏里面找到你刚刚创建的:App ID,点击Continue. 4.选择你刚创建的发布证书，根据自己电脑上的发布证书日期来选择，点击Continue. 5.在Profile Name栏里输入一个名称,这个是Provisioning Profile(简称PP文件)文件的名称,可随便输入,文件名后缀可带上日期,方便以后使用.然后点击Continue. 6.Download文件,并双击运行,点击done完成. 7.Download生成的PPFile. 六.在iTunes Connect中添加上传App信息并提交到Appstore.1.用开发者账号登陆iTunes Connect. 2.点击我的App 3.点击”+”号,然后新建App. 4.按要求填写信息,SKU是公司用于做统计数据之类的id，根据公司需求填写 5.每个描述后面的?号是苹果提供的提示平台: 名称: 语言: 套装ID: SKU: 6.填写App名称、套装ID、类别.分级位置显示:无分级.具体分级需要在后面填写. 7.填写价格、销售范围、批量购买计划. 8.需要3.5寸、4寸、4.7寸、5.5寸预览图片,每个尺寸都要至少3张. 3.5寸:640 x 960 4寸:640 x 1136 4.7寸:750 x 1334 5.5寸:1242 x 2208 9.App的描述根据公司需求填写,如果App名称为”XX助手”,关键词可以写:”XX、助手、XX助手”,关键词主要是为了让用户在AppStore上搜索应用时,能通过对应关键词能找到匹配的App. 10.iMessage App图中已经说明很清楚,一般不用处理 11.填写App图标 12.分级填写,如图分级定为17+,如果想要4+,无限制的网络访问改为否. 13.如果XX助手App涉及和带有蓝牙的硬件连接,需要上传App和硬件使用操作的视频演示地址,我上传的是优酷.(只要是App和硬件进行交互,就需要有App操作视频演示地址) 14.Apple Watch图中也说明很清楚,一般不用处理. 七.xcode打包项目1.构建版本,需要到Xcode中去打包. 2.版本选择的问题 3.打开Xcode,设备选择Generic iOS Device.然后使用快捷键Command + B,进行编译.下图中有一些简单说明 4.选择Product -&gt; Scheme -&gt; Edit Scheme 或者使用快捷键Command + &lt; ,打开界面. 5.把Run、Test、Profile、Analyze、Archive中的Build Configuration全部改为Release.之后Close. 6.编译成功,选择Product -&gt; Archive.进行打包. 7.打包后弹窗,上传给苹果团队进行测试的包不能带有iPhone等字样,因为,苹果对打包的文件名称有要求.所以,我把”Unity-iPhone”改了. 8.选择Validate进行验证,再Choose对应的付费过的开发者团队. 9.点击Validate 10.等待验证结果 11.验证失败,点击done.因为之前已经出现build为3的版本,所以,将build改为4,从步骤(五.6)再走一次流程.如果没错则继续. 12.验证成功,如下,选择done. 13.选择Upload to App Store,弹窗后还是选择付费的开发者团队. 14.选择Upload 15.等待上传 16.上传中 17.上传成功 18.返回到iTunes Connect网站中,我的App -&gt; 准备提交 -&gt; 选择构建版本右侧的”+”号. 19.选择构建版本,点击完成. 20.提交审核. 21.出现广告标识,根据情况填写,再提交. 22.App等待审核. CSDNiOS开发 – App上架流程(2017) 简书iOS开发之 App上架流程(2017)]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App上架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之苹果开发者账号注册申请流程]]></title>
    <url>%2F2017%2F05%2F16%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%8B%B9%E6%9E%9C%E5%BC%80%E5%8F%91%E8%80%85%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文介绍了苹果开发者账号注册申请流程的详细过程. 准备工作一张visa或者万事达国际信用卡（开通visa或master功能的信用卡）、公司邮箱、公司网站（需与邮箱后缀一致）。 苹果企业开发者账号，分为两种。第一种Enterprise Program为公司内部员工打包测试用，不可公开下载；对外发布的是第二种，为Developer Program。 一.Enterprise Program(苹果公司售价$299，约合￥1988).此账号的作用：企业账号是苹果给企业用户用来进行内部测试用的一种账号，我们可以通过该账号生成的证书打包APP，放于企业的内部网站上（不可上传AppStore），可供苹果用户下载安装，不过值得注意的是通过这种方式安装APP，一旦账号一年有效期到期，手机上已经安装的APP无法启动，也无法在网站上下载安装，必须重新打包发布。因此账号按期续费非常重要。此证书主要是没有安装设备数量限制（由于此特点，在测试和分发 App 时，给开发者带来了极大的便利，尤其是多人协作）。但是要注意：此账号仅仅用于内部测试，不可公开下载，苹果的管控是非常严格的，任何违背苹果条款使用企业账号，都会有企业账号被封的风险，封号之后使用该证书的APP将会闪退。 1.进入苹果开发者官网，鼠标滚动到页面最下方，选择Enterprise Program。 2.进入Enterprise Program页面之后，再选择页面中间部分的“Get started with enrollment”（开始登记）； 3.跳转到What You Need to Enroll的页面，这里就是描述了一下大概需要准备什么之类的，选择下方的“Start Your Enrollment”即可。 4.若没有登录的话，随后会弹出苹果开发者账号的登录界面。当然没有苹果账号的话，就需要去注册一个，点击“Create Apple ID”，去创建一个苹果账号。 5.创建苹果账号，需要填写一些信息，比如APPID（邮箱）、姓名（拼音）、密码（至少需要8位，含数字和大写字母）、密保问题、出生日期、国籍等。（1）Apple ID一栏填写邮箱地址（建议为公司企业邮箱）； （2）强烈建议申请苹果证书的时候建一个word文档，一方面是记录信息，另外一方面是为了下次申请或者复制粘贴信息方便，因为有可能填完一系列信息提交之后验证码已经失效了，有时页面更新一下又要重新填写（后面申请邓白氏编码时也建议如此）…… 6.填写完之后，点击“Continue”进行下一步。在邮箱收取验证码。 7.进入邮箱，收取邮件，点击“Verify”，即可验证成功。8.回到第4步，使用刚申请的账号登录，点击Sign In。9.同意一下协议，提交。 10.选择为“Company/Organization”（公司/组织）。 11.选择后弹出警告，大意就是申请苹果开发者证书之前需要申请邓白氏编码（美国的邓白氏编码用于企业的识别码），没有邓白氏编码是无法申请证书的。此处选择D-U-N-S Number下方的“Check now”进行邓白氏编码的申请。 12.在邓白氏申请页面上填写公司相关信息（均使用英文），填写完之后提交。座机需要填写能联系到本人的座机（中国区格式为86-区号+号码+分机号，如86-0755XXXXX-XX）。 13.提交后出现以下页面。这里不需要选择（列表中的均为邓白氏中已经有记录的地址），因为刚申请是不在列表内的。在此页面点击“submit your information”，之后提示“D-U-N-S Number Creation Request”，则表示信息提交成功。随后苹果公司会发送一封邮件，里面含有邓白氏申请下来的大致时间点以及该提交请求的响应码。 操作到此步，需要暂时告一段落，等待邓白氏编码的申请完成，申请下来会以邮件的形式告知，注意查收邮件。时间大概是一周，如果没下来可以根据响应码咨询。 邓白氏邮箱：applecs@dnb.com 苹果咨询热线：4006 701 855 14.经过一周漫长的等待……苹果公司会来电话，核实一些信息，比如公司名称、地址等，还会去查一下公司是否已经注册，申请人联系方式等。核实完毕就发放邓白氏编码。苹果公司会提示，得到编码后最好是过14个工作日之后使用，如要提前使用，失败不要超过3次，然后走后续流程。15.从邮件中获得邓白氏编码（D-U-N-S Number）。回到第11步，这次选择“Continue”。 16.这一步如果是公司所有者，选择第一个，如果不是公司所有者但是公司授权人，选择第二个。选择第二个区别就是需要多填一点授权人的资料。填写一下就OK。 17.这里需要填写一下邮箱上收到的邓白氏编码、公司名、公司主页、总部座机、工作邮箱。其中，总部电话Country Code填写86，Phone Number填写公司座机号（前面加区号），Extension填写分机号。例：86-0755XXXXXXXX-XXX。邮箱后缀xxx.com和公司网址域名后缀xxx.com需要保持一致，现在苹果对苹果开发者证书审核很严格，不小心就容易被拒。填写完后，点击“Continue”。 18.这一步就是验证信息，如果信息没错，在Address栏打勾，并选择Submit提交。 19.提交之后，会提示“Your enrollment is being processed”，说明开发者证书申请已经提交。好吧，接下来又是等了，大概一周左右。如果申请期间，因为资料缺失或准备不完整，造成审核退回，可以联系苹果公司4006 701 855。如果需要更新邓白氏的资料，可以发送邮件至邓白氏（若需要邓白氏协助，一般苹果回复的邮件里含有邓白氏公司的邮件地址），可以用中文或英文撰写邮件。 20.正常的话大概一周可以收到苹果公司的电话，确认基本信息和用途（公司内部测试），则收到可以继续的邮件。打开邮件的链接或者登录网站，即可继续申请。首先，同意一下协议。点击提交。 21.点击购买。Apple Developer Enterprise Program证书需要的费用为人民币￥1988。 22.选择付款方式（VISA或者MasterCard），点击继续进行购买。 23.付款完成。邮箱会收到订单邮件，这时就可以使用苹果证书了，后面快到期的时候记得续缴费用。 二.Developer Program(苹果公司售价$99，约合￥699). 此账号分为个人版，公司版。作用：用于对外发布苹果端APP，可将APP上传到AppStore（发布到AppStore就是审核比较麻烦，如果想尽快测试APP情况，可用Enterprise Program测试完，再用此证书进行对外发布到AppStore审核，否则发现问题再审核就慢了），也可以用来给开发者生成证书调试APP，利用该账号发布到AppStore上的APP可以供任一苹果用户通过AppStore下载安装。此证书有安装设备数量限制，即用于开发的设备数量为100个。 公司版申请流程（个人版更简单且不用申请邓白氏编码，在此不赘述，参考下面的就行）：公司开发者账号申请详情准备：（1.）只能用visa或者万事达国际信用卡（开通visa或master功能的信用卡）（2.）公司法人姓名公司法人的职称（3.）公司的DUNS码（邓白氏编码）（4.）公司的英文名，公司网址。 1.进入苹果开发者官网：https://developer.apple.com/，拉到页面最下方，选择Developer Program。 2.点击右上角的“Enroll”进行申请。 3.这边的注册流程可以参考第一部分的3-7步。创建Apple ID或者已经有就直接登录(创建Apple ID 这里就不讲了) 顺带一提，Developer Program和Enterprise Program都想申请的话，是需要注册两个账号的，一个账号只能用于一个证书。 4.注册了账号之后，需要选择账号类型。若是个人开发者，则选择第一项：“Individual / Sole Proprletor / Single Person Business”,公司版则选择“Company / Organization”,政府组织选择则第三个。 注意：公司版的还需要申请邓白氏编码（DUNS Number）。不过，作为公司的唯一标识，邓白氏编码可以通用。若之前申请过邓白氏编码，就可以不用申请。 这部分的申请步骤也可参考第一部分的8-14步。 5.点击continue之后的跳转到如下界面：注意 ：填写号码时，country Code填86Extension不填 填好信息之后就按下continue 6.等待邮件7.按照苹果发的邮箱里的内容操作下一步，首先同意他们的证书和协议，然后填写信用卡信息，如下图： 填写信用卡的基本信息，一般用你们老板（或者是你们负责人）的信用卡就行，但一定要是visa卡，即国际信用卡，支持双币的。 8.到此整个申请流程就完了，接下来苹果会扣费和激活开通了。后续步骤与第一部分一样，申请完之后，就可以在itunesconnect.apple.com发布appstore的应用的上线审核了，将代码打包上传即可。 参考苹果开发者账号注册申请流程 简书Markdown之简书书写换行代码缩进]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>iOS账号注册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之蓝牙使用]]></title>
    <url>%2F2017%2F05%2F16%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%93%9D%E7%89%99%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了蓝牙的简单使用 一.蓝牙概念蓝牙2.0为传统蓝牙,传统蓝牙也称为经典蓝牙.蓝牙4.0因为低耗电,所以也叫做低功耗蓝(BLE).它将三种规格集一体，包括传统蓝牙技术、高速技术和低耗能技术. 二.BLE支持两种部署方式1. 双模式低功耗蓝牙功能集成在现有的经典蓝牙控制器中，或在现有经典蓝牙技术芯片上增加低功耗堆栈，整体架构基本不变，因此成本增加有限. 2. 单模式面向高度集成、紧凑的设备，使用一个轻量级连接层(Link Layer)提供超低功耗的待机模式操作、简单设备恢复和可靠的点对多点数据传输，还能让联网传感器在蓝牙传输中安排好低功耗蓝牙流量的次序，同时还有高级节能和安全加密连接. 三.蓝牙各版本使用选择1. 蓝牙2.0,不上架使用私有API,手机需要越狱. 2. 蓝牙2.0,要上架进行MFI认证,使用ExternalAccessory框架.手机不需要越狱. 3. 蓝牙4.0,要上架使用CoreBluetooth框架,手机不需要越狱.(CoreBluetooth是基于BLE来开发的) 4. 说明对于小的硬件厂商来说,MFI认证通过几率不大,不仅耗钱还耗时,所以,还是推荐使用蓝牙4.0.(MFI:Make for ipad ,iphone, itouch 专们为苹果设备制作的设备) 四.问题描述公司要求iOS端需要和钢琴进行蓝牙连接并进行数据通信,我以为钢琴是蓝牙4.0,然后快速集成CoreBluetooth框架写了一个demo,扫描外设时,没有发现钢琴的蓝牙名称,可是用iphone打开系统设置,可以发现钢琴对应的蓝牙.问了安卓的同事,得知钢琴的蓝牙只有2.0的模块,所以,安卓端是用2.0蓝牙进行交互的.公司决定不做MFI认证,改用蓝牙4.0.在与硬件厂商交涉的过程中,得知钢琴中的蓝牙是4.0的,但是,他们在设计蓝牙板子的时候,没有集成低功耗技术.之后,板子寄回硬件厂商,添加BLE模块.这才踏上蓝牙4.0的正轨. 五.蓝牙4.0使用解析1.基本知识central:中心,连接硬件的设备.peripheral:外设,被连接的硬件.说明:外设在一直广播,当你创建的中心对象在扫描外设时,就能够发现外设.如图所示:service:服务.characteristic:特征.说明:一个外设包含多个服务,而每一个服务中又包含多个特征,特征包括特征的值和特征的描述.每个服务包含多个字段,字段的权限有read(读)、write(写)、notify(通知). 2.蓝牙4.0分为两种模式中心模式流程 建立中心角色 [[CBCentralManager alloc] initWithDelegate:self queue:nil] 扫描外设 cancelPeripheralConnection 发现外设 didDiscoverPeripheral 连接外设 connectPeripheral4.1 连接失败 didFailToConnectPeripheral4.2 连接断开 didDisconnectPeripheral4.3 连接成功 didConnectPeripheral 扫描外设中的服务 discoverServices5.1 发现并获取外设中的服务 didDiscoverServices 扫描外设对应服务的特征 discoverCharacteristics6.1 发现并获取外设对应服务的特征 didDiscoverCharacteristicsForService6.2 给对应特征写数据 writeValue:forCharacteristic:type: 订阅特征的通知 setNotifyValue:forCharacteristic:7.1 根据特征读取数据 didUpdateValueForCharacteristic 外设模式流程 建立外设角色 设置本地外设的服务和特征 发布外设和特征 广播服务 响应中心的读写请求 发送更新的特征值，订阅中心 六.蓝牙4.0开发步骤1.本文采用中心模式导入CoreBluetooth框架,#import &lt;CoreBluetooth/CoreBluetooth.h&gt; 2.遵守CBCentralManagerDelegate,CBPeripheralDelegate协议3.添加属性12345678910// 中心管理者(管理设备的扫描和连接)@property (nonatomic, strong) CBCentralManager *centralManager;// 存储的设备@property (nonatomic, strong) NSMutableArray *peripherals;// 扫描到的设备@property (nonatomic, strong) CBPeripheral *cbPeripheral;// 文本@property (weak, nonatomic) IBOutlet UITextView *peripheralText;// 外设状态@property (nonatomic, assign) CBManagerState peripheralState; 常量,具体服务和特征是读还是写的类型,问公司硬件厂商,或者问同事.12345678910// 蓝牙4.0设备名static NSString * const kBlePeripheralName = @"公司硬件蓝牙名称";// 通知服务static NSString * const kNotifyServerUUID = @"FFE0";// 写服务static NSString * const kWriteServerUUID = @"FFE1";// 通知特征值static NSString * const kNotifyCharacteristicUUID = @"FFE2";// 写特征值static NSString * const kWriteCharacteristicUUID = @"FFE3"; 4.创建中心管理者12345678- (CBCentralManager *)centralManager&#123; if (!_centralManager) &#123; _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil]; &#125; return _centralManager;&#125; 创建存储设备数组1234567- (NSMutableArray *)peripherals&#123; if (!_peripherals) &#123; _peripherals = [NSMutableArray array]; &#125; return _peripherals;&#125; 5.扫描设备之前会调用中心管理者状态改变的方法12345678910111213141516171819202122232425262728293031323334353637383940414243// 当状态更新时调用(如果不实现会崩溃)- (void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; switch (central.state) &#123; case CBManagerStateUnknown:&#123; NSLog(@"未知状态"); self.peripheralState = central.state; &#125; break; case CBManagerStateResetting: &#123; NSLog(@"重置状态"); self.peripheralState = central.state; &#125; break; case CBManagerStateUnsupported: &#123; NSLog(@"不支持的状态"); self.peripheralState = central.state; &#125; break; case CBManagerStateUnauthorized: &#123; NSLog(@"未授权的状态"); self.peripheralState = central.state; &#125; break; case CBManagerStatePoweredOff: &#123; NSLog(@"关闭状态"); self.peripheralState = central.state; &#125; break; case CBManagerStatePoweredOn: &#123; NSLog(@"开启状态－可用状态"); self.peripheralState = central.state; &#125; break; default: break; &#125;&#125; 扫描设备123456789101112// 扫描设备- (IBAction)scanForPeripherals&#123; [self.centralManager stopScan]; NSLog(@"扫描设备"); [self showMessage:@"扫描设备"]; if (self.peripheralState == CBManagerStatePoweredOn) &#123; // 扫描所有设备,传入nil,代表所有设备. [self.centralManager scanForPeripheralsWithServices:nil options:nil]; &#125;&#125; 6.扫描到设备并开始连接12345678910111213141516171819202122232425262728/** 扫描到设备 @param central 中心管理者 @param peripheral 扫描到的设备 @param advertisementData 广告信息 @param RSSI 信号强度 */- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *,id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; [self showMessage:[NSString stringWithFormat:@"发现设备,设备名:%@",peripheral.name]]; if (![self.peripherals containsObject:peripheral]) &#123; [self.peripherals addObject:peripheral]; NSLog(@"%@",peripheral); if ([peripheral.name isEqualToString:kBlePeripheralName]) &#123; [self showMessage:[NSString stringWithFormat:@"设备名:%@",peripheral.name]]; self.cbPeripheral = peripheral; [self showMessage:@"开始连接"]; [self.centralManager connectPeripheral:peripheral options:nil]; &#125; &#125;&#125; 7.连接的三种状态,如果连接成功,则扫描所有服务(也可以扫描指定服务)连接失败重连123456789101112131415/** 连接失败 @param central 中心管理者 @param peripheral 连接失败的设备 @param error 错误信息 */- (void)centralManager:(CBCentralManager *)central didFailToConnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; [self showMessage:@"连接失败"]; if ([peripheral.name isEqualToString:kBlePeripheralName]) &#123; [self.centralManager connectPeripheral:peripheral options:nil]; &#125;&#125; 连接断开重连123456789101112131415/** 连接断开 @param central 中心管理者 @param peripheral 连接断开的设备 @param error 错误信息 */- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; [self showMessage:@"断开连接"]; if ([peripheral.name isEqualToString:kBlePeripheralName]) &#123; [self.centralManager connectPeripheral:peripheral options:nil]; &#125;&#125; 连接成功并扫描服务12345678910111213141516/** 连接成功 @param central 中心管理者 @param peripheral 连接成功的设备 */- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; NSLog(@"连接设备:%@成功",peripheral.name); [self showMessage:[NSString stringWithFormat:@"连接设备:%@成功",peripheral.name]]; // 设置设备的代理 peripheral.delegate = self; // services:传入nil代表扫描所有服务 [peripheral discoverServices:nil];&#125; 8.发现服务并扫描服务对应的特征1234567891011121314151617181920/** 扫描到服务 @param peripheral 服务对应的设备 @param error 扫描错误信息 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error&#123; // 遍历所有的服务 for (CBService *service in peripheral.services) &#123; NSLog(@"服务:%@",service.UUID.UUIDString); // 获取对应的服务 if ([service.UUID.UUIDString isEqualToString:kWriteServerUUID] || [service.UUID.UUIDString isEqualToString:kNotifyServerUUID]) &#123; // 根据服务去扫描特征 [peripheral discoverCharacteristics:nil forService:service]; &#125; &#125;&#125; 9.扫描到对应的特征,写入特征的值,并订阅指定的特征通知.1234567891011121314151617181920212223242526272829303132333435/** 扫描到对应的特征 @param peripheral 设备 @param service 特征对应的服务 @param error 错误信息 */- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; // 遍历所有的特征 for (CBCharacteristic *characteristic in service.characteristics) &#123; NSLog(@"特征值:%@",characteristic.UUID.UUIDString); // 获取对应的特征 if ([characteristic.UUID.UUIDString isEqualToString:kWriteCharacteristicUUID]) &#123; // 写入数据 [self showMessage:@"写入特征值"]; for (Byte i = 0x0; i &lt; 0x73; i++) &#123; // 让钢琴的每颗灯都亮一次 Byte byte[] = &#123;0xf0, 0x3d, 0x3d, i, 0x02,0xf7&#125;; NSData *data = [NSData dataWithBytes:byte length:6]; [peripheral writeValue:data forCharacteristic:characteristic type:CBCharacteristicWriteWithResponse]; &#125; &#125; if ([characteristic.UUID.UUIDString isEqualToString:kNotifyCharacteristicUUID]) &#123; // 订阅特征通知 [peripheral setNotifyValue:YES forCharacteristic:characteristic]; &#125; &#125;&#125; 10.根据特征读取到数据123456789101112131415/** 根据特征读到数据 @param peripheral 读取到数据对应的设备 @param characteristic 特征 @param error 错误信息 */- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(nonnull CBCharacteristic *)characteristic error:(nullable NSError *)error&#123; if ([characteristic.UUID.UUIDString isEqualToString:kNotifyCharacteristicUUID]) &#123; NSData *data = characteristic.value; NSLog(@"%@",data); &#125;&#125; 读取值打印结果:12342017-04-25 12:34:41.876974+0800 蓝牙4.0Demo[1745:346611] &lt;9f5436&gt;2017-04-25 12:34:41.983016+0800 蓝牙4.0Demo[1745:346611] &lt;8f5440&gt;2017-04-25 12:34:42.154821+0800 蓝牙4.0Demo[1745:346611] &lt;9f5649&gt;2017-04-25 12:34:42.239481+0800 蓝牙4.0Demo[1745:346611] &lt;8f5640&gt; 提示:上Appstore下载LightBlue,进行蓝牙通信测试. GitHub蓝牙4.0Demo CSDNiOS开发之蓝牙使用 简书iOS开发之蓝牙使用]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之NSAttributedString使用]]></title>
    <url>%2F2017%2F04%2F28%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20NSAttributedString%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了NSAttributedString和NSMutableAttributedString的用法. 一. NSAttributedString介绍摘自NSAttributedString.h文件1@interface NSAttributedString : NSObject &lt;NSCopying, NSMutableCopying, NSSecureCoding&gt; 它由2部分组成1.文字内容 : NSString *2.文字属性: NSDictionary *1234文字颜色 - NSForegroundColorAttributeName字体大小 - NSFontAttributeName下划线 - NSUnderlineStyleAttributeName背景色 - NSBackgroundColorAttributeName 二.NSMutableAttributedString介绍摘自NSAttributedString.h文件1@interface NSMutableAttributedString : NSAttributedString NSMutableAttributedString常用的有三种方法:1.设置range范围的属性, 重复设置同一个范围的属性, 后面一次设置会覆盖前面的设置.1- (void)setAttributes:(nullable NSDictionary&lt;NSString *, id&gt; *)attrs range:(NSRange)range; 2.添加range范围的属性, 同一个范围, 可以不断添加属性.1- (void)addAttribute:(NSString *)name value:(id)value range:(NSRange)range; 3.一次性添加一个范围内的多个属性.1- (void)addAttributes:(NSDictionary&lt;NSString *, id&gt; *)attrs range:(NSRange)range; 三.需求-给文本框设置占位文字的字体颜色、背景颜色以及下划线.通过xib或者storyboard创建的界面,在界面右侧是找不到对应的设置属性. 四.解决方法1.通过NSAttributedString实现,自定义一个继承至UITextField的类,在awakeFromNib方法中写以下代码.12345NSMutableDictionary *attributes = [NSMutableDictionary dictionary];attributes[NSForegroundColorAttributeName] = [UIColor yellowColor];attributes[NSBackgroundColorAttributeName] = [UIColor redColor];attributes[NSUnderlineStyleAttributeName] = @YES;self.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@"o惜乐o" attributes:attributes]; 效果图如下: 注意 : 别忘记指定UITextField的Class如图: 方法2:通过NSMutableAttributedString实现.代码如下:1234567NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@"o惜乐o"];NSMutableDictionary *attributes = [NSMutableDictionary dictionary];attributes[NSForegroundColorAttributeName] = [UIColor yellowColor];attributes[NSBackgroundColorAttributeName] = [UIColor redColor];attributes[NSUnderlineStyleAttributeName] = @YES;[string setAttributes:attributes range:NSMakeRange(0, 4)];self.attributedPlaceholder = string; 方法3:12345NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@"o惜乐o"];[string addAttribute:NSForegroundColorAttributeName value:[UIColor yellowColor] range:NSMakeRange(0, 4)];[string addAttribute:NSBackgroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, 4)];[string addAttribute:NSUnderlineStyleAttributeName value:@YES range:NSMakeRange(0, 4)];self.attributedPlaceholder = string; 方法4:重写drawPlaceholderInRect方法1234567NSMutableDictionary *attributes = [NSMutableDictionary dictionary];attributes[NSForegroundColorAttributeName] = [UIColor whiteColor];attributes[NSBackgroundColorAttributeName] = [UIColor redColor];attributes[NSFontAttributeName] = self.font;attributes[NSUnderlineStyleAttributeName] = @YES;CGPoint placeholderPoint = CGPointMake(0, (rect.size.height - self.font.lineHeight) * 0.5);[self.placeholder drawAtPoint:placeholderPoint withAttributes:attributes]; 方法5:通过视图分层可以看出,UITextField中包含UITextFieldLabel. 而占位视图是通过什么来显示呢?根据self.subviews.lastObject.class,可知占位图是通过UITextFieldLabel显示的,根据self.subviews.lastObject.superClass可知UITextFieldLabel的父类是UILabel,所以可以使用.textColor方法去显示文字颜色.但是,不能保证self.subviews.lastObject.class方法中取到的一定是UITextFieldLabel.所以运行时就上场了. 因为UITextFieldLabel在UITextField.h头文件中找不到具体内容,只是简单的@class声明一下,所以需要利用运行时,查看UITextField的成员变量或属性,结果,你高兴的发现了这个家伙 – placeholderLabel,这时候可以理解为placeholderLabel属性指向UITextFieldLabel所对应的内容,所以占位视图也是placeholderLabel啦!!!那么,也可以通过.textColor设置颜色.123456789unsigned int count;Ivar *ivarList = class_copyIvarList([UITextField class], &amp;count);for (int i = 0; i &lt; count; i++)&#123; Ivar ivar = ivarList[i]; NSString *str = [NSString stringWithUTF8String:ivar_getName(ivar)]; NSLog(@"%@", str); &#125;free(ivarList); 用KVC最终得出:1234static NSString * const kPlaceholderColorKey = @"placeholderLabel.textColor";static NSString * const kPlaceholderBGColorKey = @"placeholderLabel.backgroundColor";[self setValue:[UIColor yellowColor] forKeyPath:kPlaceholderColorKey];[self setValue:[UIColor redColor] forKeyPath:kPlaceholderBGColorKey]; 设置下划线无法用KCV实现,如果非要用,还是会绕回第一种写法1234NSMutableDictionary *attributes = [NSMutableDictionary dictionary];attributes[NSUnderlineStyleAttributeName] = @YES;NSAttributedString *attributeText = [[NSAttributedString alloc] initWithString:@"o惜乐o" attributes:attributes];[self setValue:attributeText forKeyPath:kPlaceholderUnderLineKey]; 说明:UITextFieldLabel的父类为UILabel.UILabel中有TextColor属性,而UILabel继承自UIView,UIView中有backgroundColor属性.所以UITextFieldLabel就可以设置文字颜色和背景颜色.而placeholderLabel是程序内部私有的属性,指向UITextFieldLabel的内容,所以也能设置文字颜色和背景颜色. GitHubNSAttributedStringDemo 简书iOS开发之NSAttributedString使用]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSAttributedString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之规范文档]]></title>
    <url>%2F2017%2F04%2F21%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[一.语言采用US(美式)英语,不使UK(英式)英语或汉字拼音.123US: UIColor *myColor =[UIColor blueColor];UK: UIColor *myColour =[UIColor blueColor];拼音: UIColor *wodeYanSe =[UIColor blueColor]; 二.命名规则1.常量的命名在前面加上小写字母k作为标记.其余遵循小驼峰命名法(第一个单词全部小写,后面单词首字母大写).1NSTimeInterval kAnimationDuration = 0.3; 2.宏的命名以两个大写字母作为前缀,后面遵循大驼峰命名法.12#define KKScreenWidth ([UIScreen mainScreen].bounds.size.width)#define KKAppVersion @"appVersion" 3.枚举的命名遵循Objective-C内部框架定义方式.Enum中枚举内容的命名需要以该Enum类型名称开头.1234567typedef NS_ENUM(NSInteger, FulowersMoveDestination)&#123; FulowersMoveDestinationTop, FulowersMoveDestinationBottom, FulowersMoveDestinationLeft, FulowersMoveDestinationRight,&#125;; 4.类的命名整体采用大驼峰式命名(每个单词的首字母大写).类前缀:采用开发者姓名的首字母大写.类后缀:采用对应类的全称.1234NavigationController 导航控制器: LBYNavigationControllerViewController 主页视图控制器: LBYHomeViewControllerTableViewController 表格控制器: LBYTableViewControllerTabBarController 标签控制器: LBYTabBarController 5.方法的命名当方法参数在三个以及三个以上,换行保持对齐(冒号对齐,冒号前是参数变量,冒号后是参数值).方法声明:12345+ (instancetype)initWithPersonName:(NSString *)name withAge:(int)age withSex:(NSString *)sex withHeight:(float)height withWeight:(float)weight; 方法调用:避免使用冒号对齐的方式. 6.属性和对象的命名采用修饰+类型的方式命名,BOOL类型添加is前缀,单词遵循小驼峰命名法.声明属性时,小括号中的顺序依次是:nonatomic,readonly,strong.12345@property (nonatomic, assign) BOOL isLogin;@property (nonatomic, weak) UITextField *loginNameTextField;@property (nonatomic, copy) NSString *studentClientName;@property (nonatomic, weak) UILabel *loginTipLabel;@property (nonatomic, weak) UIButton *loginButton; 三.注释注释是为了解释说明,方法或变量等命名规范合理,清楚易懂,可以不添加注释,含有复杂逻辑的代码必须添加注释.注释需要实时更新,跟随代码的变动进行更改或者删除. 1.公开类方法注释在.h文件中声明类方法,采用文档注释,要写明方法的具体作用,所有参数的含义以及返回的参数值.123456789101112131415/** 创建person对象的类方法 @param name 姓名 @param age 年龄 @param sex 性别 @param height 身高 @param weight 体重 @return 返回person类对象*/+ (instancetype)initWithPersonName:(NSString *)name withAge:(int)age withSex:(NSString *)sex withHeight:(float)height withWeight:(float)weight; 2.私有的对象方法注释在.m文件中实现对象方法,采用文档注释, 要写明方法的具体作用, 如果有参数和返回值,需要添加所有参数的含义以及返回的参数值.1234/** 搭建tableview的UI*/- (void)setupTableViewUI 3.方法内部逻辑代码注释复杂逻辑代码在代码上方进行注释,注释方式采用双斜杠+单个空格+具体注释内容123456789- (void)viewDidLoad&#123; [super ViewDidLoad]; // 注释 if(...) &#123; ... &#125; &#125; 4.属性注释1234/** 登陆按钮*/@property (nonatomic, weak) UIButton *loginBtn; 5.标记在函数分组和使用#pragma mark - 给重要逻辑代码添加标记,方便阅读1234567891011121314151617181920212223242526272829303132#pragma mark - Lifecycle- (instancetype)init - (void)dealloc - (void)viewDidLoad - (void)viewWillAppear:(BOOL)animated - (void)didReceiveMemoryWarning #pragma mark - IBActions- (IBAction)submitData:(id)sender #pragma mark - Public- (void)publicMethod #pragma mark - Private- (void)privateMethod #pragma mark - Custom Protocol- (void)tabbarBottomView:(LBYTabbarBottomView *)tabbarBottomView didSelectIndex:(NSUInteger)index didSelectBtn:(BYBottomButton *)selectBtn#pragma mark - UITextFieldDelegate- (void)textViewDidBeginEditing:(UITextView *)textView;- (void)textViewDidEndEditing:(UITextView *)textView; #pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; #pragma mark - UITableViewDelegate- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;#pragma mark - NSObject- (NSString *)description 6.打印关于NSLog,在项目或者SDK完成最终版本时,需要去掉打印的注释(可以使用pch预编译文件来禁止NSLog打印) 四.格式化1.赋值在”=”号左右两边各间隔一个空格.1static const int count = 0; 类方法或对象方法方法的”+/-”号和左侧小括号间隔一个空格,大括号换行,上下大括号对齐.1234- (void)viewDidLoad &#123;&#125; 2.属性声明property和左侧小括号间隔一个空格,逗号和下一个属性修饰符间隔一个空格,右侧小括号和属性类型间隔一个空格,属性类型和属性变量间隔一个空格.声明字符串类型时,NSString和号间隔一个空格,号和属性变量相连,应是*studentClientName```,不是```NSString* studentClientName```,也不是```NSString * studentClientName```.123```objc@property (nonatomic, assign, readwrite) BOOL isLogin;@property (nonatomic, copy, readwrite) NSString *studentClientName; 3.for循环for和左侧小括号间隔一个空格, i和”&lt;=”间隔一个空格, ”&lt;=”和”3”间隔一个空格, ”3”后面紧跟着封号 ,封号和i间隔一个空格.大括号换行,一对大括号上下位置对齐.1234for (int i = 0; i &lt;= 3; i++)&#123; // 语句&#125; 4.条件语句关于大括号,任何需要大括号的都不能省略.采用1234if (isLogin)&#123; return success;&#125; 不是12if (isLogin) return success; 也不是1if (isLogin) return success; 5.case语句当一个case语句包含多行代码时,大括号应该加上.如case 2所示.123456789101112131415161718switch (condition) &#123; case 1: // ... break; case 2: &#123; // ... // Multi-line example using braces break; &#125; case 3: // ... break; default: // ... break; &#125; 当在switch使用枚举类型时，default是不需要的.123456789101112131415switch (FulowersMoveDestination) &#123; case FulowersMoveDestinationTop: // ... break; case FulowersMoveDestinationBottom: // ... break; case FulowersMoveDestinationLeft: // ... break; case FulowersMoveDestinationRight: // ... break; &#125; 五.单例统一采用shared+类名作为单例类的方法名12345678910111213@implementation LBYNetworkTool+ (instancetype)sharedBYNetworkTool&#123; static LBYNetworkTool *instance; &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[LBYNetworkTool alloc]init]; &#125;); &#125; return instance;&#125;@end 六.UI整理搭建UI时,使用setup作为方法名前缀,将相应UI布局放在对应方法中123- (void)setupTableViewUI- (void)setupNavigationUI- (void)setupCollectionViewUI 简书iOS开发之规范文档]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>规范文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之Xcode自定义代码块迁移]]></title>
    <url>%2F2016%2F11%2F26%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BXcode%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E5%9D%97%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[本文介绍了代码块迁移的过程. 一.Xcode中的代码块. 二.打开 Finder,快捷键Command + Shift + G.弹出文本框. 三.在路径中输入以下路径.点击前往.~/Library/Developer/Xcode/UserData/CodeSnippets 四.复制红色框的文件,粘贴到新的mac上Xcode中对应的位置.如果新的mac上的Xcode对应路径中没有CodeSnippets文件夹,就在Xcode中随意添加一个自定义代码块,CodeSnippets文件就会生成. 简书iOS开发之Xcode自定义代码块迁移]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之类型转换]]></title>
    <url>%2F2016%2F08%2F07%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[本文介绍了常见的类型转换. 一.NSString和NSData的互相转换.NSString 转 NSData.123NSString *testStr1 = @"better";NSData *testData1 = [testStr1 dataUsingEncoding:NSUTF8StringEncoding];NSLog(@"testData:%@",testData1); 结果:12017-06-06 17:37:44.950912+0800 test1[9204:3141182] testData:&lt;62657474 6572&gt; NSData 转 NSString.12NSString *testStr2 = [[NSString alloc] initWithData:testData1 encoding:NSUTF8StringEncoding];NSLog(@"testStr:%@",testStr2); 结果:12017-06-06 17:37:44.951103+0800 test1[9204:3141182] testStr:better 二.NSData和Byte互相转换.NSData 转 Byte数组.1234567NSString *testStr3 = @"better";NSData *testData2 = [testStr3 dataUsingEncoding: NSUTF8StringEncoding];Byte *testByte1 = (Byte *)[testData2 bytes];for (int i = 0; i &lt; [testData2 length]; i++)&#123; NSLog(@"%d",testByte1[i]);&#125; 结果:1234562017-06-06 17:37:44.951213+0800 test1[9204:3141182] 982017-06-06 17:37:44.951250+0800 test1[9204:3141182] 1012017-06-06 17:37:44.951283+0800 test1[9204:3141182] 1162017-06-06 17:37:44.951314+0800 test1[9204:3141182] 1162017-06-06 17:37:44.951345+0800 test1[9204:3141182] 1012017-06-06 17:37:44.951376+0800 test1[9204:3141182] 114 说明:NSData默认含有bytes的只读属性,可直接调用.1@property (readonly) const void *bytes NS_RETURNS_INNER_POINTER; Byte数组 转 NSData.123Byte byteArr[] = &#123;98,101,116,116,101,114&#125;;NSData *testData3 = [[NSData alloc] initWithBytes:byteArr length:sizeof(byteArr)/sizeof(Byte)];NSLog(@"%@",testData3); 结果:12017-06-06 17:44:21.302122+0800 test1[9209:3143384] &lt;62657474 6572&gt; 三. 十六进制和十进制互相转换.十六进制 转 十进制 (系统方法)12NSUInteger testData4 = strtoul([testHexStr UTF8String],0,16);NSLog(@"%zd",testData4); 结果:12017-06-06 18:22:00.746316+0800 test1[9286:3154681] 190 strtoul说明:1234//参数1：字符串起始地址.//参数2：返回字符串有效数字的结束地址,这也是为什么要用二级指针的原因.//参数3：转换基数.当base=0,自动判断字符串的类型,并按10进制输出.strtoul(const char *__str, char **__endptr, int __base); 十进制 转 十六进制 (系统方法)12NSString *testHexStr = [NSString stringWithFormat:@"%@",[[NSString alloc] initWithFormat:@"%x",190]];NSLog(@"%@",testHexStr); 结果:12017-06-06 18:22:00.746256+0800 test1[9286:3154681] be 说明:转换结果不带0X前缀,如果需要带0X前缀,且是小写字母,使用%#x打印格式,若是大写字母,使用%#X打印格式. 十六进制 转 十进制 (自己实现 – 出自之类型转换)1234567891011121314151617181920212223242526272829303132// 十六进制转十进制 - (NSString *)convertDecimalWithHexStr:(NSString *)hexStr&#123; int decimal = 0; UniChar hexChar = ' '; NSInteger hexLength = [hexStr length]; for (NSInteger i = 0; i &lt; hexLength; i++) &#123; int base; hexChar = [hexStr characterAtIndex:i]; if (hexChar &gt;= '0' &amp;&amp; hexChar &lt;= '9') &#123; // 0 的Ascll - 48 base = (hexChar - 48); &#125; else if (hexChar &gt;= 'A' &amp;&amp; hexChar &lt;= 'F') &#123; // A 的Ascll - 65 base = (hexChar - 55); &#125; else &#123; // a 的Ascll - 97 base = (hexChar - 87); &#125; decimal = decimal + base * pow(16, hexLength - i - 1); &#125; return [NSString stringWithFormat:@"%d",decimal];&#125; 调用:1NSLog(@"%@",[self convertDecimalWithHexStr:@"AbCdE"]); 结果:12017-06-07 00:59:06.852111+0800 十六进制转十进制[9450:3194324] 703710 十进制 转 十六进制 (自己实现 – 出自之类型转换)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 十进制转十六进制- (NSString *)convertHexStrWithDecimal:(NSInteger)decimal&#123; NSMutableString *HexStr = [NSMutableString string]; NSString *currentStr = [NSString string]; // 余数 NSInteger remainder = 0; // 商 NSInteger quotient = 0; do &#123; // 余数 remainder = decimal % 16; quotient = decimal / 16; switch (remainder) &#123; case 10: currentStr = @"a"; break; case 11: currentStr = @"b"; break; case 12: currentStr = @"c"; break; case 13: currentStr = @"d"; break; case 14: currentStr = @"e"; break; case 15: currentStr = @"f"; break; default: currentStr = [NSString stringWithFormat:@"%zd",remainder]; break; &#125; // 将获得的字符串插入第一个位置 [HexStr insertString:currentStr atIndex:0]; // 将商作为新的计算值. decimal = quotient; &#125; while (quotient != 0); return HexStr;&#125; 调用:1NSLog(@"%@",[self convertHexStrWithDecimal:703710]); 结果:12017-06-07 00:59:06.851867+0800 十六进制转十进制[9450:3194324] abcde GitHubiOS类型转换TypeConvertDemo 简书iOS类型转换]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Unity交互之界面跳转]]></title>
    <url>%2F2016%2F05%2F24%2FiOS%E5%92%8CUnity%E4%BA%A4%E4%BA%92%E4%B9%8B%E7%95%8C%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[本文介绍了iOS和Unity交互,主要涉及两个界面之间的跳转. 如果对iOS和Unity交互传参方法不熟悉的朋友,可以参考我的另一篇文章iOS和Unity交互之参数传递 一.程序启动入口.main.mm了解OC或者C的朋友一定知道main方法,这是整个程序的入口.以下是Unity转iOS工程后的main文件中的部分代码.123456789101112131415161718192021 const char* AppControllerClassName = "UnityAppController";int main(int argc, char* argv[])&#123; @autoreleasepool &#123; UnityInitTrampoline(); UnityParseCommandLine(argc, argv); RegisterMonoModules(); NSLog(@"-&gt; registered mono modules %p\n", &amp;constsection); RegisterFeatures(); std::signal(SIGPIPE, SIG_IGN); // 程序启动入口 UIApplicationMain(argc, argv, nil, [NSString stringWithUTF8String:AppControllerClassName]); &#125; return 0; &#125; 根据代码得知,程序需要创建UnityAppController对象.那么,程序就来到了UnityAppController文件.在UnityAppController.mm文件中的以下方法中添加打印:NSLog(@&quot;%s&quot;,__func__);12345- (id)init- (void)startUnity:(UIApplication*)application- (BOOL)application:(UIApplication*)application willFinishLaunchingWithOptions:(NSDictionary*)launchOptions- (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions- (void)applicationDidBecomeActive:(UIApplication*)application 打印结果为:12345678910111213141516172017-05-24 04:50:09.597338+0800 ProductName[5622:1888712] [DYMTLInitPlatform] platform initialization successful2017-05-24 04:50:09.693476+0800 ProductName[5622:1888655] -&gt; registered mono modules 0x100df3fa02017-05-24 04:50:09.714814+0800 ProductName[5622:1888655](标记) -[UnityAppController init]2017-05-24 04:50:09.930542+0800 ProductName[5622:1888655] -[UnityAppController application:willFinishLaunchingWithOptions:]2017-05-24 04:50:09.931002+0800 ProductName[5622:1888655](标记) -[UnityAppController application:didFinishLaunchingWithOptions:]-&gt; applicationDidFinishLaunching()2017-05-24 04:50:10.013760+0800 ProductName[5622:1888655] Metal GPU Frame Capture Enabled2017-05-24 04:50:10.014789+0800 ProductName[5622:1888655] Metal API Validation Enabled2017-05-24 04:50:10.178127+0800 ProductName[5622:1888655](标记) -[UnityAppController applicationDidBecomeActive:]-&gt; applicationDidBecomeActive()2017-05-24 04:50:10.190176+0800 ProductName[5622:1888655](标记) -[UnityAppController startUnity:]Init: screen size 640x1136Initializing Metal device caps: Apple A7 GPUInitialize engine version: 5.3.5f1 (960ebf59018a)UnloadTime: 2.714958 msSetting up 1 worker threads for Enlighten.Thread -&gt; id: 16ea3b000 -&gt; priority: 1 根据带(标记)的打印结果得知1.程序会先调用- (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions方法,进行Unity界面初始化并布局UI.2.准备激活Unity,已激活程序则调用- (void)applicationDidBecomeActive:(UIApplication*)application方法,方法中设置了UnityPause(0);表示Unity为启动状态,在方法最后,执行[self performSelector:@selector(startUnity:) withObject:application afterDelay:0];.3.调用- (void)startUnity:(UIApplication*)application方法,展示Unity界面. 二.Unity跳转iOS界面.程序启动为Unity界面,通过点击跳转iOS按钮,调用unityToIOS方法创建iOS界面并将iOS创建的控制器设置为窗口的跟控制器.以实现跳转iOS界面..cs代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using UnityEngine;using System.Collections;using System.Runtime.InteropServices;using SClassLibrary;public class Test : MonoBehaviour&#123; public GameObject cube; // DllImport这个方法相当于是告诉Unity，有一个unityToIOS函数在外部会实现。 // 使用这个方法必须要导入System.Runtime.InteropServices; [DllImport("__Internal")] private static extern void unityToIOS(string str); // 向右转函数接口 public void turnRight(string num) &#123; float f; if (float.TryParse(num, out f)) &#123;// 将string转换为float，IOS传递数据只能用以string类型 Vector3 r = new Vector3(cube.transform.rotation.x, cube.transform.rotation.y + f, cube.transform.rotation.z); cube.transform.Rotate(r); &#125; &#125; // 向左转函数接口 public void turnLeft(string num) &#123; float f; if (float.TryParse(num, out f)) &#123;// 将string转换为float，IOS传递数据只能用以string类型 Vector3 r = new Vector3(cube.transform.rotation.x, cube.transform.rotation.y - f, cube.transform.rotation.z); cube.transform.Rotate(r); &#125; &#125; public void DllTest() &#123; var user = new User &#123; Id = 1, Name = "张三" &#125;; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR unityToIOS(user.ToString()); #else Debug.Log(user.ToString()); #endif &#125; &#125; 添加属性,该属性用来保存创建的iOS控制器(尽量设置为私有属性)123@interface UnityAppController ()@property (nonatomic, strong) UIViewController *vc;@end Unity会调用unityToIOS方法,跳转iOS界面之前,先暂停Unity,即UnityPause(true);方法.因为在C语言中,不能直接使用self调用对象方法.所以需要通过GetAppController()调用setupIOS方法.GetAppController()即UnityAppController类型的对象.在setupIOS方法中,让UnityAppController对象持有vc后,再将vc直接设置为窗口的跟控制器GetAppController().window.rootViewController = GetAppController().vc;unityToIOS方法 1234567891011121314// 跳转iOS界面 extern "C" void unityToIOS(char *str) &#123; // Unity传递过来的参数 NSLog(@"%s",str); UnityPause(true); // GetAppController()获取appController，相当于self // 设置iOS界面,GetAppController()获取appController，相当于self [GetAppController() setupIOS]; // 点击按钮后跳转到IOS界面,设置窗口的跟控制器为iOS的控制 GetAppController().window.rootViewController = GetAppController().vc; &#125; setupIOS 方法12345678910111213141516171819// 设置iOS界面- (void)setupIOS &#123; UIViewController *vc = [[UIViewController alloc] init]; vc.view.backgroundColor = [UIColor greenColor]; vc.view.frame = [UIScreen mainScreen].bounds; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(70, 530, 180, 30)]; btn.backgroundColor = [UIColor whiteColor]; [btn setTitle:@"跳转到Unity界面" forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [btn addTarget:self action:@selector(setupUnity) forControlEvents:UIControlEventTouchUpInside]; [vc.view addSubview:btn]; self.vc = vc; NSLog(@"设置界面为IOS界面"); self.window.rootViewController = vc; &#125; 说明:1.GetAppController()跳转到GetAppController()方法内部,实现如下,可以看出,该方法获取到UIApplication的单例类,而它的代理,则为UnityAppController对象,最后再使用(UnityAppController*)进行强制转换.所以,在UnityAppController.mm文件中使用GetAppController()相当于self.1234inline UnityAppController *GetAppController()&#123; return (UnityAppController*)[UIApplication sharedApplication].delegate;&#125; 2.UnityGetGLViewController()返回Unity的根控制器,根控制器上的视图是Unity的视图.,如果将窗口的根控制器设置为UnityGetGLViewController(),其实就是将Unity界面显示在手机上.1234extern "C" UIViewController *UnityGetGLViewController()&#123; return GetAppController().rootViewController; &#125; 3.UnityGetGLView()返回Unity视图,这个视图其实就是显示在UnityGetGLViewController()上的.1234extern "C" UIView *UnityGetGLView()&#123; return GetAppController().unityView; &#125; 三.iOS跳转Unity界面.实现iOS界面中的按钮的方法.来跳转到Unity界面.self.rootViewController的作用相当于GetAppController().rootViewController,然后设置window的rootViewController为Unity的跟控制器setupUnity 方法123456789101112// 设置Unity界面 - (void)setupUnity &#123; // 设置Unity状态为开启状态 UnityPause(false); // 设置rootViewController为Unity的跟控制器 self.window.rootViewController = self.rootViewController; // 等同于 // self.window.rootViewController = UnityGetGLViewController(); NSLog(@"设置rootView为Unity界面"); &#125; 四.封装界面跳转代码.查看UnityAppController.mm文件,发现其中代码太多,为了减少代码以及便于我们管理和维护,我们要创建一个单例类来管理Unity和iOS界面互相跳转的操作.之前在UnityAppController.mm文件中写的代码全部删除. 1.需要创建一个自定义类,如:BYJumpEachOther,继承至NSObject.2.添加属性12// 存储的iOS控制器@property (nonatomic, strong) UIViewController *vc; 3.入口:unityToIOS,与之前不同的是,调用setupIOS方法,改为单例对象去调用[[BYJumpEachOther sharedInstance] setupIOS];获取vc也通过单例对象去获取.1234567891011121314151617// 跳转iOS界面extern "C" void unityToIOS(char *str)&#123; // Unity传递过来的参数 NSLog(@"%s",str); // 跳转到IOS界面,Unity界面暂停 UnityPause(true); // GetAppController()获取UnityAppController对象 // UnityGetGLView()获取UnityView对象,相当于_window [[BYJumpEachOther sharedInstance] setupIOS]; // 点击按钮后跳转到IOS界面,设置界面为IOS界面 GetAppController().window.rootViewController = [BYJumpEachOther sharedInstance].vc;&#125; 4.添加BYJumpEachOther创建单例的方法123456789 + (instancetype)sharedInstance&#123; static BYJumpEachOther *instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[BYJumpEachOther alloc] init]; &#125;); return instance;&#125; 5.跳转iOS界面代码1234567891011121314151617181920// 设置iOS界面 - (void)setupIOS&#123; UIViewController *vc = [[UIViewController alloc] init]; vc.view.backgroundColor = [UIColor greenColor]; vc.view.frame = [UIScreen mainScreen].bounds; UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(70, 530, 180, 30)]; btn.backgroundColor = [UIColor whiteColor]; [btn setTitle:@"跳转到Unity界面" forState:UIControlStateNormal]; [btn setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [btn addTarget:self action:@selector(setupUnity) forControlEvents:UIControlEventTouchUpInside]; [vc.view addSubview:btn]; self.vc = vc; NSLog(@"设置界面为IOS界面"); GetAppController().window.rootViewController = vc;&#125; 6.跳转Unity界面代码12345678910// 设置Unity界面- (void)setupUnity&#123; UnityPause(false); GetAppController().window.rootViewController = UnityGetGLViewController(); // 等同于 // GetAppController().window.rootViewController = GetAppController().rootViewController; NSLog(@"设置rootView为Unity界面");&#125; CSDNiOS和Unity交互之界面跳转 GitHubiOS和Unity界面交互Demo(未封装版) iOS和Unity界面交互Demo(封装版) 简书iOS和Unity交互之界面跳转]]></content>
      <categories>
        <category>iOS和Unity交互</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
        <tag>iOS和Unity交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS和Unity交互之参数传递]]></title>
    <url>%2F2016%2F03%2F07%2FiOS%E5%92%8CUnity%E4%BA%A4%E4%BA%92%E4%B9%8B%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[本文介绍了iOS和Unity交互,主要涉及参数的传递.(整个程序都处于Unity界面) 调用方法一:Unity调方法传参,有返回值.Unity代码:123[DllImport("__Internal")]// 给iOS传string参数,有返回值,返回值通过iOS的return方法返回给Unityprivate static extern string getIPv6(string mHost, string mPort) iOS通过return方法,将值返回给UnityiOS代码:123456789101112/**获取IPv6的值,并返回给Unity @param mHost 主机名 @param mPort 端口号 @return IPv6值 */extern "C" const char *getIPv6(const char *mHost, const char *mPort)&#123; // strdup(const char *__s1) 复制mHost字符串,通过Malloc()进行空间分配 return strdup(mHost);&#125; 注意:1.如果Unity传参为string类型,不执行strdup()方法而使用return mHost方法,导致mHost没有分配内存空间而报错.报错信息:12skins(2509,0x1a8e5cb40) malloc: *** error for object 0x16fdc9114: pointer being freed was not allocated*** set a breakpoint in malloc_error_break to debug 2.如果Unity传参为int类型,可以使用return mHost方法.Unity代码:123[DllImport("__Internal")]// 给iOS传int参数,无返回值,返回值通过iOS的return方法返回给Unityprivate static extern int setMyInt(int date); iOS代码:12345// 返回int值extern "C" int setMyInt(int date)&#123; return date;&#125; 3.Unity方法中参数的变量名为date,在iOS中的extern “C” int setMyInt(int date)方法中设置的参数变量名可以与Unity的相同,设置为date,也可以是a、b、c等自定义参数变量,但是为了代码规范,尽量和Unity参数保持一致.4.调用DllImport(“”)方法,需要引入命名空间:using System.Runtime.InteropServices;5.extern “C”修饰的变量和函数是按照C语言方式编译和连接的. 调用方法二:Unity调方法传参,无返回值.Unity代码:1234// 传数据给iOS[DllImport("__Internal")]// 给iOS传string参数,无返回值,返回值通过iOS的UnitySendMessage方法返回给Unityprivate static extern void setDate(string date); 1234// 接收iOS的数据public void GetDate(string date)&#123;&#125; iOS调方法,传参给UnityiOS代码:1234567891011121314151617/** 返回Unity日期 @param date 日期 @return 无返回值 */extern "C" void setDate(const char *date)&#123; /** 发送数据给Unity @param obj 模型名 @param method Unity接收iOS数据的方法名 @param msg 传给Unity的数据 UnitySendMessage(const char* obj, const char* method, const char* msg); */ UnitySendMessage("PublicGameObject", "GetDate", date);&#125; 注意iOS通过UnitySendMessage方法返回数据给Unity时,需要传正确的date值,如果UnitySendMessage方法中的第三个参数不是将date作为参数,而是自定义的NSString类,需要做类型转换(Unity中的字符串为string,OC中的字符串为NSString)如下代码:12345extern "C" void setDate(const char *date)&#123; NSString *dateStr = @"Hello Word"; UnitySendMessage("PublicGameObject", "GetDate", [dateStr UTF8String]);&#125; 以下是全部代码Unity的.cs文件:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using UnityEngine;using System.Collections;using System.Runtime.InteropServices;using UnityEngine.UI;public class Iossdk : MonoBehaviour&#123; // getIPv6方法单独使用,setDate和GetDate配合使用 public InputField[] ips; [DllImport("__Internal")] // 给iOS传string参数,有返回值,返回值通过iOS的return方法返回给Unity private static extern string getIPv6(string mHost, string mPort) [DllImport("__Internal")] // 给iOS传string参数,无返回值,返回值通过iOS的UnitySendMessage方法返回给Unity private static extern void setDate(string date); [DllImport("__Internal")] // 给iOS传int参数,无返回值,返回值通过iOS的return方法返回给Unity private static extern int setMyInt(int date); // 传int参数给iOS public void SetMyInt() &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR int result = setMyInt(int.Parse(ips[1].text)); Debug.Log(result); #else Debug.Log(int.Parse(ips[1].text)); #endif &#125; // 传string参数给iOS public void SetDate() &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR setDate(ips[0].text); #else Debug.Log(ips[0].text); #endif &#125; // 接收iOS的数据 public void GetDate(string date) &#123; ips[1].text = date; Debug.Log(date); &#125; // 通过主机名和端口号获取IPv6 public static string GetIPv6(string mHost, string mPort) &#123; #if UNITY_IPHONE &amp;&amp; !UNITY_EDITOR string mIPv6 = getIPv6(mHost, mPort); return mIPv6; #else return mHost + " : " + mPort; #endif &#125; // 程序入口1 public void Click1() &#123; string s = GetIPv6(ips[0].text, ips[1].text); Debug.Log(s); &#125; // iOS程序入口2 public void Click2() &#123; SetDate(); &#125; // iOS程序入口3 public void Click3() &#123; SetMyInt(); &#125;&#125; iOS代码:.h文件12345#import &lt;Foundation/Foundation.h&gt;@interface IOSToUnity : NSObject@end .m文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import "IOSToUnity.h" @implementation IOSToUnity /** 获取IPv6的值,并返回给Unity @param mHost 主机名 @param mPort 端口号 @return IPv6值 */extern "C" const char * getIPv6(const char *mHost, const char *mPort)&#123; // strdup(const char *__s1) 复制mHost字符串,通过Malloc()进行空间分配 return strdup(mHost);&#125; /** 返回Unity日期 @param date 日期 @return 无返回值 */extern "C" void setDate(const char *date)&#123; /** 发送数据给Unity @param obj 模型名 @param method Unity接收iOS数据的方法名 @param msg 传给Unity的数据 UnitySendMessage(const char* obj, const char* method, const char* msg); */ UnitySendMessage("PublicGameObject", "GetDate", date);&#125; /** 返回int值 @param mHost 主机名 @return 主机名 */ extern "C" int setMyInt(int date) &#123; return date; &#125; @end 如果已经掌握本文参数传递的方法,不妨看下界面交互的部分.简书iOS和Unity交互之参数传递 iOS和Unity交互之界面跳转]]></content>
      <categories>
        <category>iOS和Unity交互</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
        <tag>iOS和Unity交互</tag>
      </tags>
  </entry>
</search>